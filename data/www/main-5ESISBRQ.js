var Ws = Object.defineProperty, qs = Object.defineProperties; var Zs = Object.getOwnPropertyDescriptors; var Fr = Object.getOwnPropertySymbols; var Ys = Object.prototype.hasOwnProperty, Qs = Object.prototype.propertyIsEnumerable; var Pr = (e, t, n) => t in e ? Ws(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, W = (e, t) => { for (var n in t ||= {}) Ys.call(t, n) && Pr(e, n, t[n]); if (Fr) for (var n of Fr(t)) Qs.call(t, n) && Pr(e, n, t[n]); return e }, te = (e, t) => qs(e, Zs(t)); var kr = null; var Wt = 1, Lr = Symbol("SIGNAL"); function _(e) { let t = kr; return kr = e, t } var jr = { version: 0, lastCleanEpoch: 0, dirty: !1, producerNode: void 0, producerLastReadVersion: void 0, producerIndexOfThis: void 0, nextProducerIndex: 0, liveConsumerNode: void 0, liveConsumerIndexOfThis: void 0, consumerAllowSignalWrites: !1, consumerIsAlwaysLive: !1, producerMustRecompute: () => !1, producerRecomputeValue: () => { }, consumerMarkedDirty: () => { }, consumerOnSignalRead: () => { } }; function Ks(e) { if (!(Yt(e) && !e.dirty) && !(!e.dirty && e.lastCleanEpoch === Wt)) { if (!e.producerMustRecompute(e) && !qt(e)) { e.dirty = !1, e.lastCleanEpoch = Wt; return } e.producerRecomputeValue(e), e.dirty = !1, e.lastCleanEpoch = Wt } } function Vr(e) { return e && (e.nextProducerIndex = 0), _(e) } function Br(e, t) { if (_(t), !(!e || e.producerNode === void 0 || e.producerIndexOfThis === void 0 || e.producerLastReadVersion === void 0)) { if (Yt(e)) for (let n = e.nextProducerIndex; n < e.producerNode.length; n++)Zt(e.producerNode[n], e.producerIndexOfThis[n]); for (; e.producerNode.length > e.nextProducerIndex;)e.producerNode.pop(), e.producerLastReadVersion.pop(), e.producerIndexOfThis.pop() } } function qt(e) { at(e); for (let t = 0; t < e.producerNode.length; t++) { let n = e.producerNode[t], r = e.producerLastReadVersion[t]; if (r !== n.version || (Ks(n), r !== n.version)) return !0 } return !1 } function Hr(e) { if (at(e), Yt(e)) for (let t = 0; t < e.producerNode.length; t++)Zt(e.producerNode[t], e.producerIndexOfThis[t]); e.producerNode.length = e.producerLastReadVersion.length = e.producerIndexOfThis.length = 0, e.liveConsumerNode && (e.liveConsumerNode.length = e.liveConsumerIndexOfThis.length = 0) } function Zt(e, t) { if (Js(e), at(e), e.liveConsumerNode.length === 1) for (let r = 0; r < e.producerNode.length; r++)Zt(e.producerNode[r], e.producerIndexOfThis[r]); let n = e.liveConsumerNode.length - 1; if (e.liveConsumerNode[t] = e.liveConsumerNode[n], e.liveConsumerIndexOfThis[t] = e.liveConsumerIndexOfThis[n], e.liveConsumerNode.length--, e.liveConsumerIndexOfThis.length--, t < e.liveConsumerNode.length) { let r = e.liveConsumerIndexOfThis[t], o = e.liveConsumerNode[t]; at(o), o.producerIndexOfThis[r] = t } } function Yt(e) { return e.consumerIsAlwaysLive || (e?.liveConsumerNode?.length ?? 0) > 0 } function at(e) { e.producerNode ??= [], e.producerIndexOfThis ??= [], e.producerLastReadVersion ??= [] } function Js(e) { e.liveConsumerNode ??= [], e.liveConsumerIndexOfThis ??= [] } function Xs() { throw new Error } var ea = Xs; function $r(e) { ea = e } function S(e) { return typeof e == "function" } function ut(e) { let n = e(r => { Error.call(r), r.stack = new Error().stack }); return n.prototype = Object.create(Error.prototype), n.prototype.constructor = n, n } var ct = ut(e => function (n) {
  e(this), this.message = n ? `${n.length} errors occurred during unsubscription:
${n.map((r, o) => `${o + 1}) ${r.toString()}`).join(`
  `)}` : "", this.name = "UnsubscriptionError", this.errors = n
}); function ke(e, t) { if (e) { let n = e.indexOf(t); 0 <= n && e.splice(n, 1) } } var b = class e { constructor(t) { this.initialTeardown = t, this.closed = !1, this._parentage = null, this._finalizers = null } unsubscribe() { let t; if (!this.closed) { this.closed = !0; let { _parentage: n } = this; if (n) if (this._parentage = null, Array.isArray(n)) for (let i of n) i.remove(this); else n.remove(this); let { initialTeardown: r } = this; if (S(r)) try { r() } catch (i) { t = i instanceof ct ? i.errors : [i] } let { _finalizers: o } = this; if (o) { this._finalizers = null; for (let i of o) try { Ur(i) } catch (s) { t = t ?? [], s instanceof ct ? t = [...t, ...s.errors] : t.push(s) } } if (t) throw new ct(t) } } add(t) { var n; if (t && t !== this) if (this.closed) Ur(t); else { if (t instanceof e) { if (t.closed || t._hasParent(this)) return; t._addParent(this) } (this._finalizers = (n = this._finalizers) !== null && n !== void 0 ? n : []).push(t) } } _hasParent(t) { let { _parentage: n } = this; return n === t || Array.isArray(n) && n.includes(t) } _addParent(t) { let { _parentage: n } = this; this._parentage = Array.isArray(n) ? (n.push(t), n) : n ? [n, t] : t } _removeParent(t) { let { _parentage: n } = this; n === t ? this._parentage = null : Array.isArray(n) && ke(n, t) } remove(t) { let { _finalizers: n } = this; n && ke(n, t), t instanceof e && t._removeParent(this) } }; b.EMPTY = (() => { let e = new b; return e.closed = !0, e })(); var Qt = b.EMPTY; function lt(e) { return e instanceof b || e && "closed" in e && S(e.remove) && S(e.add) && S(e.unsubscribe) } function Ur(e) { S(e) ? e() : e.unsubscribe() } var A = { onUnhandledError: null, onStoppedNotification: null, Promise: void 0, useDeprecatedSynchronousErrorHandling: !1, useDeprecatedNextContext: !1 }; var me = { setTimeout(e, t, ...n) { let { delegate: r } = me; return r?.setTimeout ? r.setTimeout(e, t, ...n) : setTimeout(e, t, ...n) }, clearTimeout(e) { let { delegate: t } = me; return (t?.clearTimeout || clearTimeout)(e) }, delegate: void 0 }; function zr(e) { me.setTimeout(() => { let { onUnhandledError: t } = A; if (t) t(e); else throw e }) } function Kt() { } var Gr = Jt("C", void 0, void 0); function Wr(e) { return Jt("E", void 0, e) } function qr(e) { return Jt("N", e, void 0) } function Jt(e, t, n) { return { kind: e, value: t, error: n } } var ne = null; function De(e) { if (A.useDeprecatedSynchronousErrorHandling) { let t = !ne; if (t && (ne = { errorThrown: !1, error: null }), e(), t) { let { errorThrown: n, error: r } = ne; if (ne = null, n) throw r } } else e() } function Zr(e) { A.useDeprecatedSynchronousErrorHandling && ne && (ne.errorThrown = !0, ne.error = e) } var H = class extends b { constructor(t) { super(), this.isStopped = !1, t ? (this.destination = t, lt(t) && t.add(this)) : this.destination = ra } static create(t, n, r) { return new ye(t, n, r) } next(t) { this.isStopped ? en(qr(t), this) : this._next(t) } error(t) { this.isStopped ? en(Wr(t), this) : (this.isStopped = !0, this._error(t)) } complete() { this.isStopped ? en(Gr, this) : (this.isStopped = !0, this._complete()) } unsubscribe() { this.closed || (this.isStopped = !0, super.unsubscribe(), this.destination = null) } _next(t) { this.destination.next(t) } _error(t) { try { this.destination.error(t) } finally { this.unsubscribe() } } _complete() { try { this.destination.complete() } finally { this.unsubscribe() } } }, ta = Function.prototype.bind; function Xt(e, t) { return ta.call(e, t) } var tn = class { constructor(t) { this.partialObserver = t } next(t) { let { partialObserver: n } = this; if (n.next) try { n.next(t) } catch (r) { dt(r) } } error(t) { let { partialObserver: n } = this; if (n.error) try { n.error(t) } catch (r) { dt(r) } else dt(t) } complete() { let { partialObserver: t } = this; if (t.complete) try { t.complete() } catch (n) { dt(n) } } }, ye = class extends H { constructor(t, n, r) { super(); let o; if (S(t) || !t) o = { next: t ?? void 0, error: n ?? void 0, complete: r ?? void 0 }; else { let i; this && A.useDeprecatedNextContext ? (i = Object.create(t), i.unsubscribe = () => this.unsubscribe(), o = { next: t.next && Xt(t.next, i), error: t.error && Xt(t.error, i), complete: t.complete && Xt(t.complete, i) }) : o = t } this.destination = new tn(o) } }; function dt(e) { A.useDeprecatedSynchronousErrorHandling ? Zr(e) : zr(e) } function na(e) { throw e } function en(e, t) { let { onStoppedNotification: n } = A; n && me.setTimeout(() => n(e, t)) } var ra = { closed: !0, next: Kt, error: na, complete: Kt }; var Yr = typeof Symbol == "function" && Symbol.observable || "@@observable"; function Qr(e) { return e } function Kr(e) { return e.length === 0 ? Qr : e.length === 1 ? e[0] : function (n) { return e.reduce((r, o) => o(r), n) } } var ve = (() => { class e { constructor(n) { n && (this._subscribe = n) } lift(n) { let r = new e; return r.source = this, r.operator = n, r } subscribe(n, r, o) { let i = ia(n) ? n : new ye(n, r, o); return De(() => { let { operator: s, source: a } = this; i.add(s ? s.call(i, a) : a ? this._subscribe(i) : this._trySubscribe(i)) }), i } _trySubscribe(n) { try { return this._subscribe(n) } catch (r) { n.error(r) } } forEach(n, r) { return r = Jr(r), new r((o, i) => { let s = new ye({ next: a => { try { n(a) } catch (u) { i(u), s.unsubscribe() } }, error: i, complete: o }); this.subscribe(s) }) } _subscribe(n) { var r; return (r = this.source) === null || r === void 0 ? void 0 : r.subscribe(n) } [Yr]() { return this } pipe(...n) { return Kr(n)(this) } toPromise(n) { return n = Jr(n), new n((r, o) => { let i; this.subscribe(s => i = s, s => o(s), () => r(i)) }) } } return e.create = t => new e(t), e })(); function Jr(e) { var t; return (t = e ?? A.Promise) !== null && t !== void 0 ? t : Promise } function oa(e) { return e && S(e.next) && S(e.error) && S(e.complete) } function ia(e) { return e && e instanceof H || oa(e) && lt(e) } function sa(e) { return S(e?.lift) } function Xr(e) { return t => { if (sa(t)) return t.lift(function (n) { try { return e(n, this) } catch (r) { this.error(r) } }); throw new TypeError("Unable to lift unknown Observable type") } } function eo(e, t, n, r, o) { return new nn(e, t, n, r, o) } var nn = class extends H { constructor(t, n, r, o, i, s) { super(t), this.onFinalize = i, this.shouldUnsubscribe = s, this._next = n ? function (a) { try { n(a) } catch (u) { t.error(u) } } : super._next, this._error = o ? function (a) { try { o(a) } catch (u) { t.error(u) } finally { this.unsubscribe() } } : super._error, this._complete = r ? function () { try { r() } catch (a) { t.error(a) } finally { this.unsubscribe() } } : super._complete } unsubscribe() { var t; if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) { let { closed: n } = this; super.unsubscribe(), !n && ((t = this.onFinalize) === null || t === void 0 || t.call(this)) } } }; var to = ut(e => function () { e(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed" }); var O = (() => { class e extends ve { constructor() { super(), this.closed = !1, this.currentObservers = null, this.observers = [], this.isStopped = !1, this.hasError = !1, this.thrownError = null } lift(n) { let r = new Ee(this, this); return r.operator = n, r } _throwIfClosed() { if (this.closed) throw new to } next(n) { De(() => { if (this._throwIfClosed(), !this.isStopped) { this.currentObservers || (this.currentObservers = Array.from(this.observers)); for (let r of this.currentObservers) r.next(n) } }) } error(n) { De(() => { if (this._throwIfClosed(), !this.isStopped) { this.hasError = this.isStopped = !0, this.thrownError = n; let { observers: r } = this; for (; r.length;)r.shift().error(n) } }) } complete() { De(() => { if (this._throwIfClosed(), !this.isStopped) { this.isStopped = !0; let { observers: n } = this; for (; n.length;)n.shift().complete() } }) } unsubscribe() { this.isStopped = this.closed = !0, this.observers = this.currentObservers = null } get observed() { var n; return ((n = this.observers) === null || n === void 0 ? void 0 : n.length) > 0 } _trySubscribe(n) { return this._throwIfClosed(), super._trySubscribe(n) } _subscribe(n) { return this._throwIfClosed(), this._checkFinalizedStatuses(n), this._innerSubscribe(n) } _innerSubscribe(n) { let { hasError: r, isStopped: o, observers: i } = this; return r || o ? Qt : (this.currentObservers = null, i.push(n), new b(() => { this.currentObservers = null, ke(i, n) })) } _checkFinalizedStatuses(n) { let { hasError: r, thrownError: o, isStopped: i } = this; r ? n.error(o) : i && n.complete() } asObservable() { let n = new ve; return n.source = this, n } } return e.create = (t, n) => new Ee(t, n), e })(), Ee = class extends O { constructor(t, n) { super(), this.destination = t, this.source = n } next(t) { var n, r; (r = (n = this.destination) === null || n === void 0 ? void 0 : n.next) === null || r === void 0 || r.call(n, t) } error(t) { var n, r; (r = (n = this.destination) === null || n === void 0 ? void 0 : n.error) === null || r === void 0 || r.call(n, t) } complete() { var t, n; (n = (t = this.destination) === null || t === void 0 ? void 0 : t.complete) === null || n === void 0 || n.call(t) } _subscribe(t) { var n, r; return (r = (n = this.source) === null || n === void 0 ? void 0 : n.subscribe(t)) !== null && r !== void 0 ? r : Qt } }; var re = class extends O { constructor(t) { super(), this._value = t } get value() { return this.getValue() } _subscribe(t) { let n = super._subscribe(t); return !n.closed && t.next(this._value), n } getValue() { let { hasError: t, thrownError: n, _value: r } = this; if (t) throw n; return this._throwIfClosed(), r } next(t) { super.next(this._value = t) } }; var rn = { now() { return (rn.delegate || Date).now() }, delegate: void 0 }; var we = class extends O { constructor(t = 1 / 0, n = 1 / 0, r = rn) { super(), this._bufferSize = t, this._windowTime = n, this._timestampProvider = r, this._buffer = [], this._infiniteTimeWindow = !0, this._infiniteTimeWindow = n === 1 / 0, this._bufferSize = Math.max(1, t), this._windowTime = Math.max(1, n) } next(t) { let { isStopped: n, _buffer: r, _infiniteTimeWindow: o, _timestampProvider: i, _windowTime: s } = this; n || (r.push(t), !o && r.push(i.now() + s)), this._trimBuffer(), super.next(t) } _subscribe(t) { this._throwIfClosed(), this._trimBuffer(); let n = this._innerSubscribe(t), { _infiniteTimeWindow: r, _buffer: o } = this, i = o.slice(); for (let s = 0; s < i.length && !t.closed; s += r ? 1 : 2)t.next(i[s]); return this._checkFinalizedStatuses(t), n } _trimBuffer() { let { _bufferSize: t, _timestampProvider: n, _buffer: r, _infiniteTimeWindow: o } = this, i = (o ? 1 : 2) * t; if (t < 1 / 0 && i < r.length && r.splice(0, r.length - i), !o) { let s = n.now(), a = 0; for (let u = 1; u < r.length && r[u] <= s; u += 2)a = u; a && r.splice(0, a + 1) } } }; function on(e, t) { return Xr((n, r) => { let o = 0; n.subscribe(eo(r, i => { r.next(e.call(t, i, o++)) })) }) } var y = class extends Error { constructor(t, n) { super(zn(t, n)), this.code = t } }; function zn(e, t) { return `${`NG0${Math.abs(e)}`}${t ? ": " + t : ""}` } function E(e) { for (let t in e) if (e[t] === E) return t; throw Error("Could not find renamed property on target object.") } function P(e) {
  if (typeof e == "string") return e; if (Array.isArray(e)) return "[" + e.map(P).join(", ") + "]"; if (e == null) return "" + e; if (e.overriddenName) return `${e.overriddenName}`; if (e.name) return `${e.name}`; let t = e.toString(); if (t == null) return "" + t; let n = t.indexOf(`
`); return n === -1 ? t : t.substring(0, n)
} function no(e, t) { return e == null || e === "" ? t === null ? "" : t : t == null || t === "" ? e : e + " " + t } var aa = E({ __forward_ref__: E }); function Fo(e) { return e.__forward_ref__ = Fo, e.toString = function () { return P(this()) }, e } function F(e) { return ua(e) ? e() : e } function ua(e) { return typeof e == "function" && e.hasOwnProperty(aa) && e.__forward_ref__ === Fo } function Po(e) { return e && !!e.\u0275providers } var ca = E({ \u0275cmp: E }), la = E({ \u0275dir: E }), da = E({ \u0275pipe: E }); var ro = E({ \u0275fac: E }), je = E({ __NG_ELEMENT_ID__: E }), oo = E({ __NG_ENV_ID__: E }); function ko(e) { return typeof e == "string" ? e : e == null ? "" : String(e) } function fa(e) { return typeof e == "function" ? e.name || e.toString() : typeof e == "object" && e != null && typeof e.type == "function" ? e.type.name || e.type.toString() : ko(e) } function pa(e, t) { let n = t ? `. Dependency path: ${t.join(" > ")} > ${e}` : ""; throw new y(-200, `Circular dependency in DI detected for ${e}${n}`) } function Gn(e, t) { throw new y(-201, !1) } function ha(e, t) { e == null && ga(t, e, null, "!=") } function ga(e, t, n, r) { throw new Error(`ASSERTION ERROR: ${e}` + (r == null ? "" : ` [Expected=> ${n} ${r} ${t} <=Actual]`)) } function I(e) { return { token: e.token, providedIn: e.providedIn || null, factory: e.factory, value: void 0 } } function Wn(e) { return { providers: e.providers || [], imports: e.imports || [] } } function qn(e) { return io(e, Lo) || io(e, jo) } function io(e, t) { return e.hasOwnProperty(t) ? e[t] : null } function ma(e) { let t = e && (e[Lo] || e[jo]); return t || null } function so(e) { return e && (e.hasOwnProperty(ao) || e.hasOwnProperty(Da)) ? e[ao] : null } var Lo = E({ \u0275prov: E }), ao = E({ \u0275inj: E }), jo = E({ ngInjectableDef: E }), Da = E({ ngInjectorDef: E }), g = function (e) { return e[e.Default = 0] = "Default", e[e.Host = 1] = "Host", e[e.Self = 2] = "Self", e[e.SkipSelf = 4] = "SkipSelf", e[e.Optional = 8] = "Optional", e }(g || {}), gn; function ya() { return gn } function N(e) { let t = gn; return gn = e, t } function Vo(e, t, n) { let r = qn(e); if (r && r.providedIn == "root") return r.value === void 0 ? r.value = r.factory() : r.value; if (n & g.Optional) return null; if (t !== void 0) return t; Gn(e, "Injector") } var Ve = globalThis; var w = class { constructor(t, n) { this._desc = t, this.ngMetadataName = "InjectionToken", this.\u0275prov = void 0, typeof n == "number" ? this.__NG_ELEMENT_ID__ = n : n !== void 0 && (this.\u0275prov = I({ token: this, providedIn: n.providedIn || "root", factory: n.factory })) } get multi() { return this } toString() { return `InjectionToken ${this._desc}` } }; var va = {}, $e = va, Ea = "__NG_DI_FLAG__", mt = "ngTempTokenPath", wa = "ngTokenPath", Ia = /\n/gm, Ca = "\u0275", uo = "__source", Be; function Ie(e) { let t = Be; return Be = e, t } function Ma(e, t = g.Default) { if (Be === void 0) throw new y(-203, !1); return Be === null ? Vo(e, void 0, t) : Be.get(e, t & g.Optional ? null : void 0, t) } function v(e, t = g.Default) { return (ya() || Ma)(F(e), t) } function M(e, t = g.Default) { return v(e, Tt(t)) } function Tt(e) { return typeof e > "u" || typeof e == "number" ? e : 0 | (e.optional && 8) | (e.host && 1) | (e.self && 2) | (e.skipSelf && 4) } function mn(e) { let t = []; for (let n = 0; n < e.length; n++) { let r = F(e[n]); if (Array.isArray(r)) { if (r.length === 0) throw new y(900, !1); let o, i = g.Default; for (let s = 0; s < r.length; s++) { let a = r[s], u = ba(a); typeof u == "number" ? u === -1 ? o = a.token : i |= u : o = a } t.push(v(o, i)) } else t.push(v(r)) } return t } function ba(e) { return e[Ea] } function Ta(e, t, n, r) {
  let o = e[mt]; throw t[uo] && o.unshift(t[uo]), e.message = _a(`
`+ e.message, o, n, r), e[wa] = o, e[mt] = null, e
} function _a(e, t, n, r = null) {
  e = e && e.charAt(0) === `
`&& e.charAt(1) == Ca ? e.slice(2) : e; let o = P(t); if (Array.isArray(t)) o = t.map(P).join(" -> "); else if (typeof t == "object") { let i = []; for (let s in t) if (t.hasOwnProperty(s)) { let a = t[s]; i.push(s + ":" + (typeof a == "string" ? JSON.stringify(a) : P(a))) } o = `{${i.join(", ")}}` } return `${n}${r ? "(" + r + ")" : ""}[${o}]: ${e.replace(Ia, `
  `)}`
} function Bo(e) { return { toString: e }.toString() } var Ho = function (e) { return e[e.OnPush = 0] = "OnPush", e[e.Default = 1] = "Default", e }(Ho || {}), j = function (e) { return e[e.Emulated = 0] = "Emulated", e[e.None = 2] = "None", e[e.ShadowDom = 3] = "ShadowDom", e }(j || {}), Ue = {}, k = [], ie = function (e) { return e[e.None = 0] = "None", e[e.SignalBased = 1] = "SignalBased", e[e.HasDecoratorInputTransform = 2] = "HasDecoratorInputTransform", e }(ie || {}); function $o(e, t, n) { let r = e.length; for (; ;) { let o = e.indexOf(t, n); if (o === -1) return o; if (o === 0 || e.charCodeAt(o - 1) <= 32) { let i = t.length; if (o + i === r || e.charCodeAt(o + i) <= 32) return o } n = o + 1 } } function Dn(e, t, n) { let r = 0; for (; r < n.length;) { let o = n[r]; if (typeof o == "number") { if (o !== 0) break; r++; let i = n[r++], s = n[r++], a = n[r++]; e.setAttribute(t, s, a, i) } else { let i = o, s = n[++r]; xa(i) ? e.setProperty(t, i, s) : e.setAttribute(t, i, s), r++ } } return r } function Sa(e) { return e === 3 || e === 4 || e === 6 } function xa(e) { return e.charCodeAt(0) === 64 } function Zn(e, t) { if (!(t === null || t.length === 0)) if (e === null || e.length === 0) e = t.slice(); else { let n = -1; for (let r = 0; r < t.length; r++) { let o = t[r]; typeof o == "number" ? n = o : n === 0 || (n === -1 || n === 2 ? co(e, n, o, null, t[++r]) : co(e, n, o, null, null)) } } return e } function co(e, t, n, r, o) { let i = 0, s = e.length; if (t === -1) s = -1; else for (; i < e.length;) { let a = e[i++]; if (typeof a == "number") { if (a === t) { s = -1; break } else if (a > t) { s = i - 1; break } } } for (; i < e.length;) { let a = e[i]; if (typeof a == "number") break; if (a === n) { if (r === null) { o !== null && (e[i + 1] = o); return } else if (r === e[i + 1]) { e[i + 2] = o; return } } i++, r !== null && i++, o !== null && i++ } s !== -1 && (e.splice(s, 0, t), i = s + 1), e.splice(i++, 0, n), r !== null && e.splice(i++, 0, r), o !== null && e.splice(i++, 0, o) } var Uo = "ng-template"; function Na(e, t, n) { let r = 0, o = !0; for (; r < e.length;) { let i = e[r++]; if (typeof i == "string" && o) { let s = e[r++]; if (n && i === "class" && $o(s.toLowerCase(), t, 0) !== -1) return !0 } else if (i === 1) { for (; r < e.length && typeof (i = e[r++]) == "string";)if (i.toLowerCase() === t) return !0; return !1 } else typeof i == "number" && (o = !1) } return !1 } function zo(e) { return e.type === 4 && e.value !== Uo } function Aa(e, t, n) { let r = e.type === 4 && !n ? Uo : e.value; return t === r } function Oa(e, t, n) { let r = 4, o = e.attrs || [], i = Pa(o), s = !1; for (let a = 0; a < t.length; a++) { let u = t[a]; if (typeof u == "number") { if (!s && !R(r) && !R(u)) return !1; if (s && R(u)) continue; s = !1, r = u | r & 1; continue } if (!s) if (r & 4) { if (r = 2 | r & 1, u !== "" && !Aa(e, u, n) || u === "" && t.length === 1) { if (R(r)) return !1; s = !0 } } else { let c = r & 8 ? u : t[++a]; if (r & 8 && e.attrs !== null) { if (!Na(e.attrs, c, n)) { if (R(r)) return !1; s = !0 } continue } let l = r & 8 ? "class" : u, d = Ra(l, o, zo(e), n); if (d === -1) { if (R(r)) return !1; s = !0; continue } if (c !== "") { let f; d > i ? f = "" : f = o[d + 1].toLowerCase(); let h = r & 8 ? f : null; if (h && $o(h, c, 0) !== -1 || r & 2 && c !== f) { if (R(r)) return !1; s = !0 } } } } return R(r) || s } function R(e) { return (e & 1) === 0 } function Ra(e, t, n, r) { if (t === null) return -1; let o = 0; if (r || !n) { let i = !1; for (; o < t.length;) { let s = t[o]; if (s === e) return o; if (s === 3 || s === 6) i = !0; else if (s === 1 || s === 2) { let a = t[++o]; for (; typeof a == "string";)a = t[++o]; continue } else { if (s === 4) break; if (s === 0) { o += 4; continue } } o += i ? 1 : 2 } return -1 } else return ka(t, e) } function Fa(e, t, n = !1) { for (let r = 0; r < t.length; r++)if (Oa(e, t[r], n)) return !0; return !1 } function Pa(e) { for (let t = 0; t < e.length; t++) { let n = e[t]; if (Sa(n)) return t } return e.length } function ka(e, t) { let n = e.indexOf(4); if (n > -1) for (n++; n < e.length;) { let r = e[n]; if (typeof r == "number") return -1; if (r === t) return n; n++ } return -1 } function lo(e, t) { return e ? ":not(" + t.trim() + ")" : t } function La(e) { let t = e[0], n = 1, r = 2, o = "", i = !1; for (; n < e.length;) { let s = e[n]; if (typeof s == "string") if (r & 2) { let a = e[++n]; o += "[" + s + (a.length > 0 ? '="' + a + '"' : "") + "]" } else r & 8 ? o += "." + s : r & 4 && (o += " " + s); else o !== "" && !R(s) && (t += lo(i, o), o = ""), r = s, i = i || !R(r); n++ } return o !== "" && (t += lo(i, o)), t } function ja(e) { return e.map(La).join(",") } function Va(e) { let t = [], n = [], r = 1, o = 2; for (; r < e.length;) { let i = e[r]; if (typeof i == "string") o === 2 ? i !== "" && t.push(i, e[++r]) : o === 8 && n.push(i); else { if (!R(o)) break; o = i } r++ } return { attrs: t, classes: n } } function _t(e) { return Bo(() => { let t = Ua(e), n = te(W({}, t), { decls: e.decls, vars: e.vars, template: e.template, consts: e.consts || null, ngContentSelectors: e.ngContentSelectors, onPush: e.changeDetection === Ho.OnPush, directiveDefs: null, pipeDefs: null, dependencies: t.standalone && e.dependencies || null, getStandaloneInjector: null, signals: e.signals ?? !1, data: e.data || {}, encapsulation: e.encapsulation || j.Emulated, styles: e.styles || k, _: null, schemas: e.schemas || null, tView: null, id: "" }); za(n); let r = e.dependencies; return n.directiveDefs = po(r, !1), n.pipeDefs = po(r, !0), n.id = Ga(n), n }) } function Ba(e) { return St(e) || Wo(e) } function Ha(e) { return e !== null } function Yn(e) { return Bo(() => ({ type: e.type, bootstrap: e.bootstrap || k, declarations: e.declarations || k, imports: e.imports || k, exports: e.exports || k, transitiveCompileScopes: null, schemas: e.schemas || null, id: e.id || null })) } function fo(e, t) { if (e == null) return Ue; let n = {}; for (let r in e) if (e.hasOwnProperty(r)) { let o = e[r], i, s, a = ie.None; Array.isArray(o) ? (a = o[0], i = o[1], s = o[2] ?? i) : (i = o, s = o), t ? (n[i] = a !== ie.None ? [r, a] : r, t[i] = s) : n[i] = r } return n } function Go(e) { return { type: e.type, name: e.name, factory: null, pure: e.pure !== !1, standalone: e.standalone === !0, onDestroy: e.type.prototype.ngOnDestroy || null } } function St(e) { return e[ca] || null } function Wo(e) { return e[la] || null } function qo(e) { return e[da] || null } function $a(e) { let t = St(e) || Wo(e) || qo(e); return t !== null ? t.standalone : !1 } function Ua(e) { let t = {}; return { type: e.type, providersResolver: null, factory: null, hostBindings: e.hostBindings || null, hostVars: e.hostVars || 0, hostAttrs: e.hostAttrs || null, contentQueries: e.contentQueries || null, declaredInputs: t, inputTransforms: null, inputConfig: e.inputs || Ue, exportAs: e.exportAs || null, standalone: e.standalone === !0, signals: e.signals === !0, selectors: e.selectors || k, viewQuery: e.viewQuery || null, features: e.features || null, setInput: null, findHostDirectiveDefs: null, hostDirectives: null, inputs: fo(e.inputs, t), outputs: fo(e.outputs), debugInfo: null } } function za(e) { e.features?.forEach(t => t(e)) } function po(e, t) { if (!e) return null; let n = t ? qo : Ba; return () => (typeof e == "function" ? e() : e).map(r => n(r)).filter(Ha) } function Ga(e) { let t = 0, n = [e.selectors, e.ngContentSelectors, e.hostVars, e.hostAttrs, e.consts, e.vars, e.decls, e.encapsulation, e.standalone, e.signals, e.exportAs, JSON.stringify(e.inputs), JSON.stringify(e.outputs), Object.getOwnPropertyNames(e.type.prototype), !!e.contentQueries, !!e.viewQuery].join("|"); for (let o of n) t = Math.imul(31, t) + o.charCodeAt(0) << 0; return t += 2147483648, "c" + t } var K = 0, m = 1, p = 2, V = 3, Z = 4, J = 5, yn = 6, ho = 7, Y = 8, Se = 9, Q = 10, $ = 11, ze = 12, go = 13, Ke = 14, se = 15, Zo = 16, Ce = 17, Yo = 18, xt = 19, Qo = 20, He = 21, sn = 22, ae = 23, U = 25, Ko = 1; var vn = 7, Wa = 8, Jo = 9, oe = 10, Xo = function (e) { return e[e.None = 0] = "None", e[e.HasTransplantedViews = 2] = "HasTransplantedViews", e }(Xo || {}); function Te(e) { return Array.isArray(e) && typeof e[Ko] == "object" } function Oe(e) { return Array.isArray(e) && e[Ko] === !0 } function ei(e) { return (e.flags & 4) !== 0 } function Qn(e) { return e.componentOffset > -1 } function qa(e) { return (e.flags & 1) === 1 } function Je(e) { return !!e.template } function Za(e) { return (e[p] & 512) !== 0 } function xe(e, t) { let n = e.hasOwnProperty(ro); return n ? e[ro] : null } var En = class { constructor(t, n, r) { this.previousValue = t, this.currentValue = n, this.firstChange = r } isFirstChange() { return this.firstChange } }; function ti(e, t, n, r) { t !== null ? t.applyValueToInputSignal(t, r) : e[n] = r } function ni() { return ri } function ri(e) { return e.type.prototype.ngOnChanges && (e.setInput = Qa), Ya } ni.ngInherit = !0; function Ya() { let e = ii(this), t = e?.current; if (t) { let n = e.previous; if (n === Ue) e.previous = t; else for (let r in t) n[r] = t[r]; e.current = null, this.ngOnChanges(t) } } function Qa(e, t, n, r, o) { let i = this.declaredInputs[r], s = ii(e) || Ka(e, { previous: Ue, current: null }), a = s.current || (s.current = {}), u = s.previous, c = u[i]; a[i] = new En(c && c.currentValue, n, u === Ue), ti(e, t, o, n) } var oi = "__ngSimpleChanges__"; function ii(e) { return e[oi] || null } function Ka(e, t) { return e[oi] = t } var mo = null; var q = function (e, t, n) { mo?.(e, t, n) }, Ja = "svg", Xa = "math", eu = !1; function tu() { return eu } function Re(e) { for (; Array.isArray(e);)e = e[K]; return e } function nu(e, t) { return Re(t[e]) } function le(e, t) { return Re(t[e.index]) } function ru(e, t) { return e.data[t] } function ou(e, t) { return e[t] } function Xe(e, t) { let n = t[e]; return Te(n) ? n : n[K] } function Kn(e) { return (e[p] & 128) === 128 } function Do(e, t) { return t == null ? null : e[t] } function si(e) { e[Ce] = 0 } function iu(e) { e[p] & 1024 || (e[p] |= 1024, Kn(e) && Ge(e)) } function ai(e) { return e[p] & 9216 || e[ae]?.dirty } function yo(e) { ai(e) ? Ge(e) : e[p] & 64 && (tu() ? (e[p] |= 1024, Ge(e)) : e[Q].changeDetectionScheduler?.notify()) } function Ge(e) { e[Q].changeDetectionScheduler?.notify(); let t = Dt(e); for (; t !== null && !(t[p] & 8192 || (t[p] |= 8192, !Kn(t)));)t = Dt(t) } function su(e, t) { if ((e[p] & 256) === 256) throw new y(911, !1); e[He] === null && (e[He] = []), e[He].push(t) } function Dt(e) { let t = e[V]; return Oe(t) ? t[V] : t } var D = { lFrame: hi(null), bindingsEnabled: !0, skipHydrationRootTNode: null }; function au() { return D.lFrame.elementDepthCount } function uu() { D.lFrame.elementDepthCount++ } function cu() { D.lFrame.elementDepthCount-- } function ui() { return D.bindingsEnabled } function lu() { return D.skipHydrationRootTNode !== null } function du(e) { return D.skipHydrationRootTNode === e } function fu() { D.skipHydrationRootTNode = null } function x() { return D.lFrame.lView } function et() { return D.lFrame.tView } function de() { let e = ci(); for (; e !== null && e.type === 64;)e = e.parent; return e } function ci() { return D.lFrame.currentTNode } function pu() { let e = D.lFrame, t = e.currentTNode; return e.isParent ? t : t.parent } function Nt(e, t) { let n = D.lFrame; n.currentTNode = e, n.isParent = t } function li() { return D.lFrame.isParent } function hu() { D.lFrame.isParent = !1 } function gu() { let e = D.lFrame, t = e.bindingRootIndex; return t === -1 && (t = e.bindingRootIndex = e.tView.bindingStartIndex), t } function mu(e) { return D.lFrame.bindingIndex = e } function Du() { return D.lFrame.bindingIndex++ } function yu() { return D.lFrame.inI18n } function vu(e, t) { let n = D.lFrame; n.bindingIndex = n.bindingRootIndex = e, wn(t) } function Eu() { return D.lFrame.currentDirectiveIndex } function wn(e) { D.lFrame.currentDirectiveIndex = e } function di(e) { D.lFrame.currentQueryIndex = e } function wu(e) { let t = e[m]; return t.type === 2 ? t.declTNode : t.type === 1 ? e[J] : null } function fi(e, t, n) { if (n & g.SkipSelf) { let o = t, i = e; for (; o = o.parent, o === null && !(n & g.Host);)if (o = wu(i), o === null || (i = i[Ke], o.type & 10)) break; if (o === null) return !1; t = o, e = i } let r = D.lFrame = pi(); return r.currentTNode = t, r.lView = e, !0 } function Jn(e) { let t = pi(), n = e[m]; D.lFrame = t, t.currentTNode = n.firstChild, t.lView = e, t.tView = n, t.contextLView = e, t.bindingIndex = n.bindingStartIndex, t.inI18n = !1 } function pi() { let e = D.lFrame, t = e === null ? null : e.child; return t === null ? hi(e) : t } function hi(e) { let t = { currentTNode: null, isParent: !0, lView: null, tView: null, selectedIndex: -1, contextLView: null, elementDepthCount: 0, currentNamespace: null, currentDirectiveIndex: -1, bindingRootIndex: -1, bindingIndex: -1, currentQueryIndex: 0, parent: e, child: null, inI18n: !1 }; return e !== null && (e.child = t), t } function gi() { let e = D.lFrame; return D.lFrame = e.parent, e.currentTNode = null, e.lView = null, e } var mi = gi; function Xn() { let e = gi(); e.isParent = !0, e.tView = null, e.selectedIndex = -1, e.contextLView = null, e.elementDepthCount = 0, e.currentDirectiveIndex = -1, e.currentNamespace = null, e.bindingRootIndex = -1, e.bindingIndex = -1, e.currentQueryIndex = 0 } function er() { return D.lFrame.selectedIndex } function ue(e) { D.lFrame.selectedIndex = e } function Iu() { return D.lFrame.currentNamespace } var Di = !0; function yi() { return Di } function vi(e) { Di = e } function Cu(e, t, n) { let { ngOnChanges: r, ngOnInit: o, ngDoCheck: i } = t.type.prototype; if (r) { let s = ri(t); (n.preOrderHooks ??= []).push(e, s), (n.preOrderCheckHooks ??= []).push(e, s) } o && (n.preOrderHooks ??= []).push(0 - e, o), i && ((n.preOrderHooks ??= []).push(e, i), (n.preOrderCheckHooks ??= []).push(e, i)) } function Ei(e, t) { for (let n = t.directiveStart, r = t.directiveEnd; n < r; n++) { let i = e.data[n].type.prototype, { ngAfterContentInit: s, ngAfterContentChecked: a, ngAfterViewInit: u, ngAfterViewChecked: c, ngOnDestroy: l } = i; s && (e.contentHooks ??= []).push(-n, s), a && ((e.contentHooks ??= []).push(n, a), (e.contentCheckHooks ??= []).push(n, a)), u && (e.viewHooks ??= []).push(-n, u), c && ((e.viewHooks ??= []).push(n, c), (e.viewCheckHooks ??= []).push(n, c)), l != null && (e.destroyHooks ??= []).push(n, l) } } function ft(e, t, n) { wi(e, t, 3, n) } function pt(e, t, n, r) { (e[p] & 3) === n && wi(e, t, n, r) } function an(e, t) { let n = e[p]; (n & 3) === t && (n &= 16383, n += 1, e[p] = n) } function wi(e, t, n, r) { let o = r !== void 0 ? e[Ce] & 65535 : 0, i = r ?? -1, s = t.length - 1, a = 0; for (let u = o; u < s; u++)if (typeof t[u + 1] == "number") { if (a = t[u], r != null && a >= r) break } else t[u] < 0 && (e[Ce] += 65536), (a < i || i == -1) && (Mu(e, n, t, u), e[Ce] = (e[Ce] & 4294901760) + u + 2), u++ } function vo(e, t) { q(4, e, t); let n = _(null); try { t.call(e) } finally { _(n), q(5, e, t) } } function Mu(e, t, n, r) { let o = n[r] < 0, i = n[r + 1], s = o ? -n[r] : n[r], a = e[s]; o ? e[p] >> 14 < e[Ce] >> 16 && (e[p] & 3) === t && (e[p] += 16384, vo(a, i)) : vo(a, i) } var _e = -1, We = class { constructor(t, n, r) { this.factory = t, this.resolving = !1, this.canSeeViewProviders = n, this.injectImpl = r } }; function bu(e) { return e instanceof We } function Tu(e) { return (e.flags & 8) !== 0 } function _u(e) { return (e.flags & 16) !== 0 } function Su(e) { return e !== _e } function In(e) { return e & 32767 } function xu(e) { return e >> 16 } function Cn(e, t) { let n = xu(e), r = t; for (; n > 0;)r = r[Ke], n--; return r } var Mn = !0; function yt(e) { let t = Mn; return Mn = e, t } var Nu = 256, Ii = Nu - 1, Ci = 5, Au = 0, L = {}; function Ou(e, t, n) { let r; typeof n == "string" ? r = n.charCodeAt(0) || 0 : n.hasOwnProperty(je) && (r = n[je]), r == null && (r = n[je] = Au++); let o = r & Ii, i = 1 << o; t.data[e + (o >> Ci)] |= i } function Mi(e, t) { let n = bi(e, t); if (n !== -1) return n; let r = t[m]; r.firstCreatePass && (e.injectorIndex = t.length, un(r.data, e), un(t, null), un(r.blueprint, null)); let o = Ti(e, t), i = e.injectorIndex; if (Su(o)) { let s = In(o), a = Cn(o, t), u = a[m].data; for (let c = 0; c < 8; c++)t[i + c] = a[s + c] | u[s + c] } return t[i + 8] = o, i } function un(e, t) { e.push(0, 0, 0, 0, 0, 0, 0, 0, t) } function bi(e, t) { return e.injectorIndex === -1 || e.parent && e.parent.injectorIndex === e.injectorIndex || t[e.injectorIndex + 8] === null ? -1 : e.injectorIndex } function Ti(e, t) { if (e.parent && e.parent.injectorIndex !== -1) return e.parent.injectorIndex; let n = 0, r = null, o = t; for (; o !== null;) { if (r = Ai(o), r === null) return _e; if (n++, o = o[Ke], r.injectorIndex !== -1) return r.injectorIndex | n << 16 } return _e } function Ru(e, t, n) { Ou(e, t, n) } function _i(e, t, n) { if (n & g.Optional || e !== void 0) return e; Gn(t, "NodeInjector") } function Si(e, t, n, r) { if (n & g.Optional && r === void 0 && (r = null), !(n & (g.Self | g.Host))) { let o = e[Se], i = N(void 0); try { return o ? o.get(t, r, n & g.Optional) : Vo(t, r, n & g.Optional) } finally { N(i) } } return _i(r, t, n) } function xi(e, t, n, r = g.Default, o) { if (e !== null) { if (t[p] & 2048 && !(r & g.Self)) { let s = ju(e, t, n, r, L); if (s !== L) return s } let i = Ni(e, t, n, r, L); if (i !== L) return i } return Si(t, n, r, o) } function Ni(e, t, n, r, o) { let i = ku(n); if (typeof i == "function") { if (!fi(t, e, r)) return r & g.Host ? _i(o, n, r) : Si(t, n, r, o); try { let s; if (s = i(r), s == null && !(r & g.Optional)) Gn(n); else return s } finally { mi() } } else if (typeof i == "number") { let s = null, a = bi(e, t), u = _e, c = r & g.Host ? t[se][J] : null; for ((a === -1 || r & g.SkipSelf) && (u = a === -1 ? Ti(e, t) : t[a + 8], u === _e || !wo(r, !1) ? a = -1 : (s = t[m], a = In(u), t = Cn(u, t))); a !== -1;) { let l = t[m]; if (Eo(i, a, l.data)) { let d = Fu(a, t, n, s, r, c); if (d !== L) return d } u = t[a + 8], u !== _e && wo(r, t[m].data[a + 8] === c) && Eo(i, a, t) ? (s = l, a = In(u), t = Cn(u, t)) : a = -1 } } return o } function Fu(e, t, n, r, o, i) { let s = t[m], a = s.data[e + 8], u = r == null ? Qn(a) && Mn : r != s && (a.type & 3) !== 0, c = o & g.Host && i === a, l = Pu(a, s, n, u, c); return l !== null ? qe(t, s, l, a) : L } function Pu(e, t, n, r, o) { let i = e.providerIndexes, s = t.data, a = i & 1048575, u = e.directiveStart, c = e.directiveEnd, l = i >> 20, d = r ? a : a + l, f = o ? a + l : c; for (let h = d; h < f; h++) { let C = s[h]; if (h < u && n === C || h >= u && C.type === n) return h } if (o) { let h = s[u]; if (h && Je(h) && h.type === n) return u } return null } function qe(e, t, n, r) { let o = e[n], i = t.data; if (bu(o)) { let s = o; s.resolving && pa(fa(i[n])); let a = yt(s.canSeeViewProviders); s.resolving = !0; let u, c = s.injectImpl ? N(s.injectImpl) : null, l = fi(e, r, g.Default); try { o = e[n] = s.factory(void 0, i, e, r), t.firstCreatePass && n >= r.directiveStart && Cu(n, i[n], t) } finally { c !== null && N(c), yt(a), s.resolving = !1, mi() } } return o } function ku(e) { if (typeof e == "string") return e.charCodeAt(0) || 0; let t = e.hasOwnProperty(je) ? e[je] : void 0; return typeof t == "number" ? t >= 0 ? t & Ii : Lu : t } function Eo(e, t, n) { let r = 1 << e; return !!(n[t + (e >> Ci)] & r) } function wo(e, t) { return !(e & g.Self) && !(e & g.Host && t) } var vt = class { constructor(t, n) { this._tNode = t, this._lView = n } get(t, n, r) { return xi(this._tNode, this._lView, t, Tt(r), n) } }; function Lu() { return new vt(de(), x()) } function ju(e, t, n, r, o) { let i = e, s = t; for (; i !== null && s !== null && s[p] & 2048 && !(s[p] & 512);) { let a = Ni(i, s, n, r | g.Self, L); if (a !== L) return a; let u = i.parent; if (!u) { let c = s[Qo]; if (c) { let l = c.get(n, L, r); if (l !== L) return l } u = Ai(s), s = s[Ke] } i = u } return o } function Ai(e) { let t = e[m], n = t.type; return n === 2 ? t.declTNode : n === 1 ? e[J] : null } function tr(e, t) { e.forEach(n => Array.isArray(n) ? tr(n, t) : t(n)) } function Oi(e, t) { return t >= e.length - 1 ? e.pop() : e.splice(t, 1)[0] } var Ze = new w("ENVIRONMENT_INITIALIZER"), Ri = new w("INJECTOR", -1), Fi = new w("INJECTOR_DEF_TYPES"), Et = class { get(t, n = $e) { if (n === $e) { let r = new Error(`NullInjectorError: No provider for ${P(t)}!`); throw r.name = "NullInjectorError", r } return n } }; function Pi(e) { return { \u0275providers: e } } function Vu(...e) { return { \u0275providers: ki(!0, e), \u0275fromNgModule: !0 } } function ki(e, ...t) { let n = [], r = new Set, o, i = s => { n.push(s) }; return tr(t, s => { let a = s; bn(a, i, [], r) && (o ||= [], o.push(a)) }), o !== void 0 && Li(o, i), n } function Li(e, t) { for (let n = 0; n < e.length; n++) { let { ngModule: r, providers: o } = e[n]; nr(o, i => { t(i, r) }) } } function bn(e, t, n, r) { if (e = F(e), !e) return !1; let o = null, i = so(e), s = !i && St(e); if (!i && !s) { let u = e.ngModule; if (i = so(u), i) o = u; else return !1 } else { if (s && !s.standalone) return !1; o = e } let a = r.has(o); if (s) { if (a) return !1; if (r.add(o), s.dependencies) { let u = typeof s.dependencies == "function" ? s.dependencies() : s.dependencies; for (let c of u) bn(c, t, n, r) } } else if (i) { if (i.imports != null && !a) { r.add(o); let c; try { tr(i.imports, l => { bn(l, t, n, r) && (c ||= [], c.push(l)) }) } finally { } c !== void 0 && Li(c, t) } if (!a) { let c = xe(o) || (() => new o); t({ provide: o, useFactory: c, deps: k }, o), t({ provide: Fi, useValue: o, multi: !0 }, o), t({ provide: Ze, useValue: () => v(o), multi: !0 }, o) } let u = i.providers; if (u != null && !a) { let c = e; nr(u, l => { t(l, c) }) } } else return !1; return o !== e && e.providers !== void 0 } function nr(e, t) { for (let n of e) Po(n) && (n = n.\u0275providers), Array.isArray(n) ? nr(n, t) : t(n) } var Bu = E({ provide: String, useValue: E }); function ji(e) { return e !== null && typeof e == "object" && Bu in e } function Hu(e) { return !!(e && e.useExisting) } function $u(e) { return !!(e && e.useFactory) } function Tn(e) { return typeof e == "function" } var At = new w("Set Injector scope."), ht = {}, Uu = {}, cn; function rr() { return cn === void 0 && (cn = new Et), cn } var ce = class { }, wt = class extends ce { get destroyed() { return this._destroyed } constructor(t, n, r, o) { super(), this.parent = n, this.source = r, this.scopes = o, this.records = new Map, this._ngOnDestroyHooks = new Set, this._onDestroyHooks = [], this._destroyed = !1, Sn(t, s => this.processProvider(s)), this.records.set(Ri, Me(void 0, this)), o.has("environment") && this.records.set(ce, Me(void 0, this)); let i = this.records.get(At); i != null && typeof i.value == "string" && this.scopes.add(i.value), this.injectorDefTypes = new Set(this.get(Fi, k, g.Self)) } destroy() { this.assertNotDestroyed(), this._destroyed = !0; try { for (let n of this._ngOnDestroyHooks) n.ngOnDestroy(); let t = this._onDestroyHooks; this._onDestroyHooks = []; for (let n of t) n() } finally { this.records.clear(), this._ngOnDestroyHooks.clear(), this.injectorDefTypes.clear() } } onDestroy(t) { return this.assertNotDestroyed(), this._onDestroyHooks.push(t), () => this.removeOnDestroy(t) } runInContext(t) { this.assertNotDestroyed(); let n = Ie(this), r = N(void 0), o; try { return t() } finally { Ie(n), N(r) } } get(t, n = $e, r = g.Default) { if (this.assertNotDestroyed(), t.hasOwnProperty(oo)) return t[oo](this); r = Tt(r); let o, i = Ie(this), s = N(void 0); try { if (!(r & g.SkipSelf)) { let u = this.records.get(t); if (u === void 0) { let c = Yu(t) && qn(t); c && this.injectableDefInScope(c) ? u = Me(_n(t), ht) : u = null, this.records.set(t, u) } if (u != null) return this.hydrate(t, u) } let a = r & g.Self ? rr() : this.parent; return n = r & g.Optional && n === $e ? null : n, a.get(t, n) } catch (a) { if (a.name === "NullInjectorError") { if ((a[mt] = a[mt] || []).unshift(P(t)), i) throw a; return Ta(a, t, "R3InjectorError", this.source) } else throw a } finally { N(s), Ie(i) } } resolveInjectorInitializers() { let t = Ie(this), n = N(void 0), r; try { let o = this.get(Ze, k, g.Self); for (let i of o) i() } finally { Ie(t), N(n) } } toString() { let t = [], n = this.records; for (let r of n.keys()) t.push(P(r)); return `R3Injector[${t.join(", ")}]` } assertNotDestroyed() { if (this._destroyed) throw new y(205, !1) } processProvider(t) { t = F(t); let n = Tn(t) ? t : F(t && t.provide), r = Gu(t); if (!Tn(t) && t.multi === !0) { let o = this.records.get(n); o || (o = Me(void 0, ht, !0), o.factory = () => mn(o.multi), this.records.set(n, o)), n = t, o.multi.push(t) } this.records.set(n, r) } hydrate(t, n) { return n.value === ht && (n.value = Uu, n.value = n.factory()), typeof n.value == "object" && n.value && Zu(n.value) && this._ngOnDestroyHooks.add(n.value), n.value } injectableDefInScope(t) { if (!t.providedIn) return !1; let n = F(t.providedIn); return typeof n == "string" ? n === "any" || this.scopes.has(n) : this.injectorDefTypes.has(n) } removeOnDestroy(t) { let n = this._onDestroyHooks.indexOf(t); n !== -1 && this._onDestroyHooks.splice(n, 1) } }; function _n(e) { let t = qn(e), n = t !== null ? t.factory : xe(e); if (n !== null) return n; if (e instanceof w) throw new y(204, !1); if (e instanceof Function) return zu(e); throw new y(204, !1) } function zu(e) { if (e.length > 0) throw new y(204, !1); let n = ma(e); return n !== null ? () => n.factory(e) : () => new e } function Gu(e) { if (ji(e)) return Me(void 0, e.useValue); { let t = Wu(e); return Me(t, ht) } } function Wu(e, t, n) { let r; if (Tn(e)) { let o = F(e); return xe(o) || _n(o) } else if (ji(e)) r = () => F(e.useValue); else if ($u(e)) r = () => e.useFactory(...mn(e.deps || [])); else if (Hu(e)) r = () => v(F(e.useExisting)); else { let o = F(e && (e.useClass || e.provide)); if (qu(e)) r = () => new o(...mn(e.deps)); else return xe(o) || _n(o) } return r } function Me(e, t, n = !1) { return { factory: e, value: t, multi: n ? [] : void 0 } } function qu(e) { return !!e.deps } function Zu(e) { return e !== null && typeof e == "object" && typeof e.ngOnDestroy == "function" } function Yu(e) { return typeof e == "function" || typeof e == "object" && e instanceof w } function Sn(e, t) { for (let n of e) Array.isArray(n) ? Sn(n, t) : n && Po(n) ? Sn(n.\u0275providers, t) : t(n) } function Io(e, t = null, n = null, r) { let o = Qu(e, t, n, r); return o.resolveInjectorInitializers(), o } function Qu(e, t = null, n = null, r, o = new Set) { let i = [n || k, Vu(e)]; return r = r || (typeof e == "object" ? void 0 : P(e)), new wt(i, t || rr(), r || null, o) } var Ot = (() => { let t = class t { static create(r, o) { if (Array.isArray(r)) return Io({ name: "" }, o, r, ""); { let i = r.name ?? ""; return Io({ name: i }, r.parent, r.providers, i) } } }; t.THROW_IF_NOT_FOUND = $e, t.NULL = new Et, t.\u0275prov = I({ token: t, providedIn: "any", factory: () => v(Ri) }), t.__NG_ELEMENT_ID__ = -1; let e = t; return e })(); var xn; function Vi(e) { xn = e } function Ku() { if (xn !== void 0) return xn; if (typeof document < "u") return document; throw new y(210, !1) } var or = new w("AppId", { providedIn: "root", factory: () => Ju }), Ju = "ng", ir = new w("Platform Initializer"), Fe = new w("Platform ID", { providedIn: "platform", factory: () => "unknown" }); var sr = new w("CSP nonce", { providedIn: "root", factory: () => Ku().body?.querySelector("[ngCspNonce]")?.getAttribute("ngCspNonce") || null }); function Xu(e) { return (e.flags & 128) === 128 } var fe = function (e) { return e[e.Important = 1] = "Important", e[e.DashCase = 2] = "DashCase", e }(fe || {}); var Bi = new Map, ec = 0; function tc() { return ec++ } function nc(e) { Bi.set(e[xt], e) } function rc(e) { Bi.delete(e[xt]) } var Co = "__ngContext__"; function Ne(e, t) { Te(t) ? (e[Co] = t[xt], nc(t)) : e[Co] = t } var oc; function Hi(e, t) { return oc(e, t) } function be(e, t, n, r, o) { if (r != null) { let i, s = !1; Oe(r) ? i = r : Te(r) && (s = !0, r = r[K]); let a = Re(r); e === 0 && n !== null ? o == null ? Gi(t, n, a) : Nn(t, n, a, o || null, !0) : e === 1 && n !== null ? Nn(t, n, a, o || null, !0) : e === 2 ? wc(t, a, s) : e === 3 && t.destroyNode(a), i != null && Cc(t, e, i, n, o) } } function ic(e, t) { return e.createText(t) } function sc(e, t, n) { e.setValue(t, n) } function $i(e, t, n) { return e.createElement(t, n) } function ac(e, t) { Ui(e, t), t[K] = null, t[J] = null } function Ui(e, t) { ur(e, t, t[$], 2, null, null) } function uc(e) { let t = e[ze]; if (!t) return ln(e[m], e); for (; t;) { let n = null; if (Te(t)) n = t[ze]; else { let r = t[oe]; r && (n = r) } if (!n) { for (; t && !t[Z] && t !== e;)Te(t) && ln(t[m], t), t = t[V]; t === null && (t = e), Te(t) && ln(t[m], t), n = t && t[Z] } t = n } } function zi(e, t) { let n = e[Jo], r = n.indexOf(t); n.splice(r, 1) } function cc(e, t) { if (e.length <= oe) return; let n = oe + t, r = e[n]; if (r) { let o = r[Zo]; o !== null && o !== e && zi(o, r), t > 0 && (e[n - 1][Z] = r[Z]); let i = Oi(e, oe + t); ac(r[m], r); let s = i[Yo]; s !== null && s.detachView(i[m]), r[V] = null, r[Z] = null, r[p] &= -129 } return r } function lc(e, t) { if (!(t[p] & 256)) { let n = t[$]; n.destroyNode && ur(e, t, n, 3, null, null), uc(t) } } function ln(e, t) { if (!(t[p] & 256)) { t[p] &= -129, t[p] |= 256, t[ae] && Hr(t[ae]), fc(e, t), dc(e, t), t[m].type === 1 && t[$].destroy(); let n = t[Zo]; if (n !== null && Oe(t[V])) { n !== t[V] && zi(n, t); let r = t[Yo]; r !== null && r.detachView(e) } rc(t) } } function dc(e, t) { let n = e.cleanup, r = t[ho]; if (n !== null) for (let i = 0; i < n.length - 1; i += 2)if (typeof n[i] == "string") { let s = n[i + 3]; s >= 0 ? r[s]() : r[-s].unsubscribe(), i += 2 } else { let s = r[n[i + 1]]; n[i].call(s) } r !== null && (t[ho] = null); let o = t[He]; if (o !== null) { t[He] = null; for (let i = 0; i < o.length; i++) { let s = o[i]; s() } } } function fc(e, t) { let n; if (e != null && (n = e.destroyHooks) != null) for (let r = 0; r < n.length; r += 2) { let o = t[n[r]]; if (!(o instanceof We)) { let i = n[r + 1]; if (Array.isArray(i)) for (let s = 0; s < i.length; s += 2) { let a = o[i[s]], u = i[s + 1]; q(4, a, u); try { u.call(a) } finally { q(5, a, u) } } else { q(4, o, i); try { i.call(o) } finally { q(5, o, i) } } } } } function pc(e, t, n) { return hc(e, t.parent, n) } function hc(e, t, n) { let r = t; for (; r !== null && r.type & 40;)t = r, r = t.parent; if (r === null) return n[K]; { let { componentOffset: o } = r; if (o > -1) { let { encapsulation: i } = e.data[r.directiveStart + o]; if (i === j.None || i === j.Emulated) return null } return le(r, n) } } function Nn(e, t, n, r, o) { e.insertBefore(t, n, r, o) } function Gi(e, t, n) { e.appendChild(t, n) } function Mo(e, t, n, r, o) { r !== null ? Nn(e, t, n, r, o) : Gi(e, t, n) } function gc(e, t, n, r) { e.removeChild(t, n, r) } function mc(e, t) { return e.parentNode(t) } function Dc(e, t, n) { return vc(e, t, n) } function yc(e, t, n) { return e.type & 40 ? le(e, n) : null } var vc = yc, bo; function Wi(e, t, n, r) { let o = pc(e, r, t), i = t[$], s = r.parent || t[J], a = Dc(s, r, t); if (o != null) if (Array.isArray(n)) for (let u = 0; u < n.length; u++)Mo(i, o, n[u], a, !1); else Mo(i, o, n, a, !1); bo !== void 0 && bo(i, r, t, n, o) } function Ec(e, t) { if (t !== null) { let r = e[se][J], o = t.projection; return r.projection[o] } return null } function wc(e, t, n) { let r = mc(e, t); r && gc(e, r, t, n) } function ar(e, t, n, r, o, i, s) { for (; n != null;) { let a = r[n.index], u = n.type; if (s && t === 0 && (a && Ne(Re(a), r), n.flags |= 2), (n.flags & 32) !== 32) if (u & 8) ar(e, t, n.child, r, o, i, !1), be(t, e, o, a, i); else if (u & 32) { let c = Hi(n, r), l; for (; l = c();)be(t, e, o, l, i); be(t, e, o, a, i) } else u & 16 ? Ic(e, t, r, n, o, i) : be(t, e, o, a, i); n = s ? n.projectionNext : n.next } } function ur(e, t, n, r, o, i) { ar(n, r, e.firstChild, t, o, i, !1) } function Ic(e, t, n, r, o, i) { let s = n[se], u = s[J].projection[r.projection]; if (Array.isArray(u)) for (let c = 0; c < u.length; c++) { let l = u[c]; be(t, e, o, l, i) } else { let c = u, l = s[V]; Xu(r) && (c.flags |= 128), ar(e, t, c, l, o, i, !0) } } function Cc(e, t, n, r, o) { let i = n[vn], s = Re(n); i !== s && be(t, e, r, i, o); for (let a = oe; a < n.length; a++) { let u = n[a]; ur(u[m], u, e, t, r, i) } } function Mc(e, t, n) { e.setAttribute(t, "style", n) } function qi(e, t, n) { n === "" ? e.removeAttribute(t, "class") : e.setAttribute(t, "class", n) } function Zi(e, t, n) { let { mergedAttrs: r, classes: o, styles: i } = n; r !== null && Dn(e, t, r), o !== null && qi(e, t, o), i !== null && Mc(e, t, i) } var An = class { }; var bc = "h", Tc = "b"; var _c = () => null; function cr(e, t, n = !1) { return _c(e, t, n) } var On = class { }, It = class { }; function Sc(e) { let t = Error(`No component factory found for ${P(e)}.`); return t[xc] = e, t } var xc = "ngComponent"; var Rn = class { resolveComponentFactory(t) { throw Sc(t) } }, lr = (() => { let t = class t { }; t.NULL = new Rn; let e = t; return e })(); function Nc() { return Yi(de(), x()) } function Yi(e, t) { return new dr(le(e, t)) } var dr = (() => { let t = class t { constructor(r) { this.nativeElement = r } }; t.__NG_ELEMENT_ID__ = Nc; let e = t; return e })(); var Ye = class { }; var Ac = (() => { let t = class t { }; t.\u0275prov = I({ token: t, providedIn: "root", factory: () => null }); let e = t; return e })(), dn = {}; function fr(e) { let t = _(null); try { return e() } finally { _(t) } } function Ct(e, t, n, r, o = !1) { for (; n !== null;) { let i = t[n.index]; i !== null && r.push(Re(i)), Oe(i) && Oc(i, r); let s = n.type; if (s & 8) Ct(e, t, n.child, r); else if (s & 32) { let a = Hi(n, t), u; for (; u = a();)r.push(u) } else if (s & 16) { let a = Ec(t, n); if (Array.isArray(a)) r.push(...a); else { let u = Dt(t[se]); Ct(u[m], u, a, r, !0) } } n = o ? n.projectionNext : n.next } return r } function Oc(e, t) { for (let n = oe; n < e.length; n++) { let r = e[n], o = r[m].firstChild; o !== null && Ct(r[m], r, o, t) } e[vn] !== e[K] && t.push(e[vn]) } var Qi = []; function Rc(e) { return e[ae] ?? Fc(e) } function Fc(e) { let t = Qi.pop() ?? Object.create(kc); return t.lView = e, t } function Pc(e) { e.lView[ae] !== e && (e.lView = null, Qi.push(e)) } var kc = te(W({}, jr), { consumerIsAlwaysLive: !0, consumerMarkedDirty: e => { Ge(e.lView) }, consumerOnSignalRead() { this.lView[ae] = this } }); function Ki(e) { return Xi(e[ze]) } function Ji(e) { return Xi(e[Z]) } function Xi(e) { for (; e !== null && !Oe(e);)e = e[Z]; return e } var Lc = "ngOriginalError"; function fn(e) { return e[Lc] } var z = class { constructor() { this._console = console } handleError(t) { let n = this._findOriginalError(t); this._console.error("ERROR", t), n && this._console.error("ORIGINAL ERROR", n) } _findOriginalError(t) { let n = t && fn(t); for (; n && fn(n);)n = fn(n); return n || null } }, es = new w("", { providedIn: "root", factory: () => M(z).handleError.bind(void 0) }); var ts = !1, jc = new w("", { providedIn: "root", factory: () => ts }); var tt = {}; function Rt(e = 1) { ns(et(), x(), er() + e, !1) } function ns(e, t, n, r) { if (!r) if ((t[p] & 3) === 3) { let i = e.preOrderCheckHooks; i !== null && ft(t, i, n) } else { let i = e.preOrderHooks; i !== null && pt(t, i, 0, n) } ue(n) } function Ft(e, t = g.Default) { let n = x(); if (n === null) return v(e, t); let r = de(); return xi(r, n, F(e), t) } function rs(e, t, n, r, o, i) { let s = _(null); try { let a = null; o & ie.SignalBased && (a = t[r][Lr]), a !== null && a.transformFn !== void 0 && (i = a.transformFn(i)), o & ie.HasDecoratorInputTransform && (i = e.inputTransforms[r].call(t, i)), e.setInput !== null ? e.setInput(t, a, i, n, r) : ti(t, a, r, i) } finally { _(s) } } function Vc(e, t) { let n = e.hostBindingOpCodes; if (n !== null) try { for (let r = 0; r < n.length; r++) { let o = n[r]; if (o < 0) ue(~o); else { let i = o, s = n[++r], a = n[++r]; vu(s, i); let u = t[i]; a(2, u) } } } finally { ue(-1) } } function pr(e, t, n, r, o, i, s, a, u, c, l) { let d = t.blueprint.slice(); return d[K] = o, d[p] = r | 4 | 128 | 8 | 64, (c !== null || e && e[p] & 2048) && (d[p] |= 2048), si(d), d[V] = d[Ke] = e, d[Y] = n, d[Q] = s || e && e[Q], d[$] = a || e && e[$], d[Se] = u || e && e[Se] || null, d[J] = i, d[xt] = tc(), d[yn] = l, d[Qo] = c, d[se] = t.type == 2 ? e[se] : d, d } function hr(e, t, n, r, o) { let i = e.data[t]; if (i === null) i = Bc(e, t, n, r, o), yu() && (i.flags |= 32); else if (i.type & 64) { i.type = n, i.value = r, i.attrs = o; let s = pu(); i.injectorIndex = s === null ? -1 : s.injectorIndex } return Nt(i, !0), i } function Bc(e, t, n, r, o) { let i = ci(), s = li(), a = s ? i : i && i.parent, u = e.data[t] = qc(e, a, n, t, r, o); return e.firstChild === null && (e.firstChild = u), i !== null && (s ? i.child == null && u.parent !== null && (i.child = u) : i.next === null && (i.next = u, u.prev = i)), u } function os(e, t, n, r) { if (n === 0) return -1; let o = t.length; for (let i = 0; i < n; i++)t.push(r), e.blueprint.push(r), e.data.push(null); return o } function is(e, t, n, r, o) { let i = er(), s = r & 2; try { ue(-1), s && t.length > U && ns(e, t, U, !1), q(s ? 2 : 0, o), n(r, o) } finally { ue(i), q(s ? 3 : 1, o) } } function ss(e, t, n) { if (ei(t)) { let r = _(null); try { let o = t.directiveStart, i = t.directiveEnd; for (let s = o; s < i; s++) { let a = e.data[s]; a.contentQueries && a.contentQueries(1, n[s], s) } } finally { _(r) } } } function Hc(e, t, n) { ui() && (Jc(e, t, n, le(n, t)), (n.flags & 64) === 64 && ls(e, t, n)) } function $c(e, t, n = le) { let r = t.localNames; if (r !== null) { let o = t.index + 1; for (let i = 0; i < r.length; i += 2) { let s = r[i + 1], a = s === -1 ? n(t, e) : e[s]; e[o++] = a } } } function as(e) { let t = e.tView; return t === null || t.incompleteFirstPass ? e.tView = us(1, null, e.template, e.decls, e.vars, e.directiveDefs, e.pipeDefs, e.viewQuery, e.schemas, e.consts, e.id) : t } function us(e, t, n, r, o, i, s, a, u, c, l) { let d = U + r, f = d + o, h = Uc(d, f), C = typeof c == "function" ? c() : c; return h[m] = { type: e, blueprint: h, template: n, queries: null, viewQuery: a, declTNode: t, data: h.slice().fill(null, d), bindingStartIndex: d, expandoStartIndex: f, hostBindingOpCodes: null, firstCreatePass: !0, firstUpdatePass: !0, staticViewQueries: !1, staticContentQueries: !1, preOrderHooks: null, preOrderCheckHooks: null, contentHooks: null, contentCheckHooks: null, viewHooks: null, viewCheckHooks: null, destroyHooks: null, cleanup: null, contentQueries: null, components: null, directiveRegistry: typeof i == "function" ? i() : i, pipeRegistry: typeof s == "function" ? s() : s, firstChild: null, schemas: u, consts: C, incompleteFirstPass: !1, ssrId: l } } function Uc(e, t) { let n = []; for (let r = 0; r < t; r++)n.push(r < e ? null : tt); return n } function zc(e, t, n, r) { let i = r.get(jc, ts) || n === j.ShadowDom, s = e.selectRootElement(t, i); return Gc(s), s } function Gc(e) { Wc(e) } var Wc = () => null; function qc(e, t, n, r, o, i) { let s = t ? t.injectorIndex : -1, a = 0; return lu() && (a |= 128), { type: n, index: r, insertBeforeIndex: null, injectorIndex: s, directiveStart: -1, directiveEnd: -1, directiveStylingLast: -1, componentOffset: -1, propertyBindings: null, flags: a, providerIndexes: 0, value: o, attrs: i, mergedAttrs: null, localNames: null, initialInputs: void 0, inputs: null, outputs: null, tView: null, next: null, prev: null, projectionNext: null, child: null, parent: t, projection: null, styles: null, stylesWithoutHost: null, residualStyles: void 0, classes: null, classesWithoutHost: null, residualClasses: void 0, classBindings: 0, styleBindings: 0 } } function To(e, t, n, r, o) { for (let i in t) { if (!t.hasOwnProperty(i)) continue; let s = t[i]; if (s === void 0) continue; r ??= {}; let a, u = ie.None; Array.isArray(s) ? (a = s[0], u = s[1]) : a = s; let c = i; if (o !== null) { if (!o.hasOwnProperty(i)) continue; c = o[i] } e === 0 ? _o(r, n, c, a, u) : _o(r, n, c, a) } return r } function _o(e, t, n, r, o) { let i; e.hasOwnProperty(n) ? (i = e[n]).push(t, r) : i = e[n] = [t, r], o !== void 0 && i.push(o) } function Zc(e, t, n) { let r = t.directiveStart, o = t.directiveEnd, i = e.data, s = t.attrs, a = [], u = null, c = null; for (let l = r; l < o; l++) { let d = i[l], f = n ? n.get(d) : null, h = f ? f.inputs : null, C = f ? f.outputs : null; u = To(0, d.inputs, l, u, h), c = To(1, d.outputs, l, c, C); let B = u !== null && s !== null && !zo(t) ? al(u, l, s) : null; a.push(B) } u !== null && (u.hasOwnProperty("class") && (t.flags |= 8), u.hasOwnProperty("style") && (t.flags |= 16)), t.initialInputs = a, t.inputs = u, t.outputs = c } function Yc(e, t, n, r) { if (ui()) { let o = r === null ? null : { "": -1 }, i = el(e, n), s, a; i === null ? s = a = null : [s, a] = i, s !== null && cs(e, t, n, s, o, a), o && tl(n, r, o) } n.mergedAttrs = Zn(n.mergedAttrs, n.attrs) } function cs(e, t, n, r, o, i) { for (let c = 0; c < r.length; c++)Ru(Mi(n, t), e, r[c].type); rl(n, e.data.length, r.length); for (let c = 0; c < r.length; c++) { let l = r[c]; l.providersResolver && l.providersResolver(l) } let s = !1, a = !1, u = os(e, t, r.length, null); for (let c = 0; c < r.length; c++) { let l = r[c]; n.mergedAttrs = Zn(n.mergedAttrs, l.hostAttrs), ol(e, n, t, u, l), nl(u, l, o), l.contentQueries !== null && (n.flags |= 4), (l.hostBindings !== null || l.hostAttrs !== null || l.hostVars !== 0) && (n.flags |= 64); let d = l.type.prototype; !s && (d.ngOnChanges || d.ngOnInit || d.ngDoCheck) && ((e.preOrderHooks ??= []).push(n.index), s = !0), !a && (d.ngOnChanges || d.ngDoCheck) && ((e.preOrderCheckHooks ??= []).push(n.index), a = !0), u++ } Zc(e, n, i) } function Qc(e, t, n, r, o) { let i = o.hostBindings; if (i) { let s = e.hostBindingOpCodes; s === null && (s = e.hostBindingOpCodes = []); let a = ~t.index; Kc(s) != a && s.push(a), s.push(n, r, i) } } function Kc(e) { let t = e.length; for (; t > 0;) { let n = e[--t]; if (typeof n == "number" && n < 0) return n } return 0 } function Jc(e, t, n, r) { let o = n.directiveStart, i = n.directiveEnd; Qn(n) && il(t, n, e.data[o + n.componentOffset]), e.firstCreatePass || Mi(n, t), Ne(r, t); let s = n.initialInputs; for (let a = o; a < i; a++) { let u = e.data[a], c = qe(t, e, a, n); if (Ne(c, t), s !== null && sl(t, a - o, c, u, n, s), Je(u)) { let l = Xe(n.index, t); l[Y] = qe(t, e, a, n) } } } function ls(e, t, n) { let r = n.directiveStart, o = n.directiveEnd, i = n.index, s = Eu(); try { ue(i); for (let a = r; a < o; a++) { let u = e.data[a], c = t[a]; wn(a), (u.hostBindings !== null || u.hostVars !== 0 || u.hostAttrs !== null) && Xc(u, c) } } finally { ue(-1), wn(s) } } function Xc(e, t) { e.hostBindings !== null && e.hostBindings(1, t) } function el(e, t) { let n = e.directiveRegistry, r = null, o = null; if (n) for (let i = 0; i < n.length; i++) { let s = n[i]; if (Fa(t, s.selectors, !1)) if (r || (r = []), Je(s)) if (s.findHostDirectiveDefs !== null) { let a = []; o = o || new Map, s.findHostDirectiveDefs(s, a, o), r.unshift(...a, s); let u = a.length; Fn(e, t, u) } else r.unshift(s), Fn(e, t, 0); else o = o || new Map, s.findHostDirectiveDefs?.(s, r, o), r.push(s) } return r === null ? null : [r, o] } function Fn(e, t, n) { t.componentOffset = n, (e.components ??= []).push(t.index) } function tl(e, t, n) { if (t) { let r = e.localNames = []; for (let o = 0; o < t.length; o += 2) { let i = n[t[o + 1]]; if (i == null) throw new y(-301, !1); r.push(t[o], i) } } } function nl(e, t, n) { if (n) { if (t.exportAs) for (let r = 0; r < t.exportAs.length; r++)n[t.exportAs[r]] = e; Je(t) && (n[""] = e) } } function rl(e, t, n) { e.flags |= 1, e.directiveStart = t, e.directiveEnd = t + n, e.providerIndexes = t } function ol(e, t, n, r, o) { e.data[r] = o; let i = o.factory || (o.factory = xe(o.type, !0)), s = new We(i, Je(o), Ft); e.blueprint[r] = s, n[r] = s, Qc(e, t, r, os(e, n, o.hostVars, tt), o) } function il(e, t, n) { let r = le(t, e), o = as(n), i = e[Q].rendererFactory, s = 16; n.signals ? s = 4096 : n.onPush && (s = 64); let a = fs(e, pr(e, o, null, s, r, t, null, i.createRenderer(r, n), null, null, null)); e[t.index] = a } function sl(e, t, n, r, o, i) { let s = i[t]; if (s !== null) for (let a = 0; a < s.length;) { let u = s[a++], c = s[a++], l = s[a++], d = s[a++]; rs(r, n, u, c, l, d) } } function al(e, t, n) { let r = null, o = 0; for (; o < n.length;) { let i = n[o]; if (i === 0) { o += 4; continue } else if (i === 5) { o += 2; continue } if (typeof i == "number") break; if (e.hasOwnProperty(i)) { r === null && (r = []); let s = e[i]; for (let a = 0; a < s.length; a += 3)if (s[a] === t) { r.push(i, s[a + 1], s[a + 2], n[o + 1]); break } } o += 2 } return r } function ds(e, t) { let n = e.contentQueries; if (n !== null) { let r = _(null); try { for (let o = 0; o < n.length; o += 2) { let i = n[o], s = n[o + 1]; if (s !== -1) { let a = e.data[s]; di(i), a.contentQueries(2, t[s], s) } } } finally { _(r) } } } function fs(e, t) { return e[ze] ? e[go][Z] = t : e[ze] = t, e[go] = t, t } function Pn(e, t, n) { di(0); let r = _(null); try { t(e, n) } finally { _(r) } } function ul(e, t) { let n = e[Se], r = n ? n.get(z, null) : null; r && r.handleError(t) } function ps(e, t, n, r, o) { for (let i = 0; i < n.length;) { let s = n[i++], a = n[i++], u = n[i++], c = t[s], l = e.data[s]; rs(l, c, r, a, u, o) } } function cl(e, t, n) { let r = nu(t, e); sc(e[$], r, n) } var ll = 100; function dl(e, t = !0) { let n = e[Q], r = n.rendererFactory, o = !1; o || r.begin?.(); try { fl(e) } catch (i) { throw t && ul(e, i), i } finally { o || (r.end?.(), n.inlineEffectRunner?.flush()) } } function fl(e) { kn(e, 0); let t = 0; for (; ai(e);) { if (t === ll) throw new y(103, !1); t++, kn(e, 1) } } function pl(e, t, n, r) { let o = t[p]; if ((o & 256) === 256) return; let i = !1; !i && t[Q].inlineEffectRunner?.flush(), Jn(t); let s = null, a = null; !i && hl(e) && (a = Rc(t), s = Vr(a)); try { si(t), mu(e.bindingStartIndex), n !== null && is(e, t, n, 2, r); let u = (o & 3) === 3; if (!i) if (u) { let d = e.preOrderCheckHooks; d !== null && ft(t, d, null) } else { let d = e.preOrderHooks; d !== null && pt(t, d, 0, null), an(t, 0) } if (gl(t), hs(t, 0), e.contentQueries !== null && ds(e, t), !i) if (u) { let d = e.contentCheckHooks; d !== null && ft(t, d) } else { let d = e.contentHooks; d !== null && pt(t, d, 1), an(t, 1) } Vc(e, t); let c = e.components; c !== null && ms(t, c, 0); let l = e.viewQuery; if (l !== null && Pn(2, l, r), !i) if (u) { let d = e.viewCheckHooks; d !== null && ft(t, d) } else { let d = e.viewHooks; d !== null && pt(t, d, 2), an(t, 2) } if (e.firstUpdatePass === !0 && (e.firstUpdatePass = !1), t[sn]) { for (let d of t[sn]) d(); t[sn] = null } i || (t[p] &= -73) } catch (u) { throw Ge(t), u } finally { a !== null && (Br(a, s), Pc(a)), Xn() } } function hl(e) { return e.type !== 2 } function hs(e, t) { for (let n = Ki(e); n !== null; n = Ji(n))for (let r = oe; r < n.length; r++) { let o = n[r]; gs(o, t) } } function gl(e) { for (let t = Ki(e); t !== null; t = Ji(t)) { if (!(t[p] & Xo.HasTransplantedViews)) continue; let n = t[Jo]; for (let r = 0; r < n.length; r++) { let o = n[r], i = o[V]; iu(o) } } } function ml(e, t, n) { let r = Xe(t, e); gs(r, n) } function gs(e, t) { Kn(e) && kn(e, t) } function kn(e, t) { let r = e[m], o = e[p], i = e[ae], s = !!(t === 0 && o & 16); if (s ||= !!(o & 64 && t === 0), s ||= !!(o & 1024), s ||= !!(i?.dirty && qt(i)), i && (i.dirty = !1), e[p] &= -9217, s) pl(r, e, r.template, e[Y]); else if (o & 8192) { hs(e, 1); let a = r.components; a !== null && ms(e, a, 1) } } function ms(e, t, n) { for (let r = 0; r < t.length; r++)ml(e, t[r], n) } function Ds(e) { for (e[Q].changeDetectionScheduler?.notify(); e;) { e[p] |= 64; let t = Dt(e); if (Za(e) && !t) return e; e = t } return null } var Qe = class { get rootNodes() { let t = this._lView, n = t[m]; return Ct(n, t, n.firstChild, []) } constructor(t, n, r = !0) { this._lView = t, this._cdRefInjectingView = n, this.notifyErrorHandler = r, this._appRef = null, this._attachedToViewContainer = !1 } get context() { return this._lView[Y] } set context(t) { this._lView[Y] = t } get destroyed() { return (this._lView[p] & 256) === 256 } destroy() { if (this._appRef) this._appRef.detachView(this); else if (this._attachedToViewContainer) { let t = this._lView[V]; if (Oe(t)) { let n = t[Wa], r = n ? n.indexOf(this) : -1; r > -1 && (cc(t, r), Oi(n, r)) } this._attachedToViewContainer = !1 } lc(this._lView[m], this._lView) } onDestroy(t) { su(this._lView, t) } markForCheck() { Ds(this._cdRefInjectingView || this._lView) } detach() { this._lView[p] &= -129 } reattach() { yo(this._lView), this._lView[p] |= 128 } detectChanges() { this._lView[p] |= 1024, dl(this._lView, this.notifyErrorHandler) } checkNoChanges() { } attachToViewContainerRef() { if (this._appRef) throw new y(902, !1); this._attachedToViewContainer = !0 } detachFromAppRef() { this._appRef = null, Ui(this._lView[m], this._lView) } attachToAppRef(t) { if (this._attachedToViewContainer) throw new y(902, !1); this._appRef = t, yo(this._lView) } }, ys = (() => { let t = class t { }; t.__NG_ELEMENT_ID__ = Dl; let e = t; return e })(); function Dl(e) { return yl(de(), x(), (e & 16) === 16) } function yl(e, t, n) { if (Qn(e) && !n) { let r = Xe(e.index, t); return new Qe(r, r) } else if (e.type & 47) { let r = t[se]; return new Qe(r, t) } return null } var So = new Set; function vs(e) { So.has(e) || (So.add(e), performance?.mark?.("mark_feature_usage", { detail: { feature: e } })) } var Ln = class extends O { constructor(t = !1) { super(), this.__isAsync = t } emit(t) { super.next(t) } subscribe(t, n, r) { let o = t, i = n || (() => null), s = r; if (t && typeof t == "object") { let u = t; o = u.next?.bind(u), i = u.error?.bind(u), s = u.complete?.bind(u) } this.__isAsync && (i = pn(i), o && (o = pn(o)), s && (s = pn(s))); let a = super.subscribe({ next: o, error: i, complete: s }); return t instanceof b && t.add(a), a } }; function pn(e) { return t => { setTimeout(e, void 0, t) } } var Le = Ln; function xo(...e) { } function vl() { let e = typeof Ve.requestAnimationFrame == "function", t = Ve[e ? "requestAnimationFrame" : "setTimeout"], n = Ve[e ? "cancelAnimationFrame" : "clearTimeout"]; if (typeof Zone < "u" && t && n) { let r = t[Zone.__symbol__("OriginalDelegate")]; r && (t = r); let o = n[Zone.__symbol__("OriginalDelegate")]; o && (n = o) } return { nativeRequestAnimationFrame: t, nativeCancelAnimationFrame: n } } var T = class e { constructor({ enableLongStackTrace: t = !1, shouldCoalesceEventChangeDetection: n = !1, shouldCoalesceRunChangeDetection: r = !1 }) { if (this.hasPendingMacrotasks = !1, this.hasPendingMicrotasks = !1, this.isStable = !0, this.onUnstable = new Le(!1), this.onMicrotaskEmpty = new Le(!1), this.onStable = new Le(!1), this.onError = new Le(!1), typeof Zone > "u") throw new y(908, !1); Zone.assertZonePatched(); let o = this; o._nesting = 0, o._outer = o._inner = Zone.current, Zone.TaskTrackingZoneSpec && (o._inner = o._inner.fork(new Zone.TaskTrackingZoneSpec)), t && Zone.longStackTraceZoneSpec && (o._inner = o._inner.fork(Zone.longStackTraceZoneSpec)), o.shouldCoalesceEventChangeDetection = !r && n, o.shouldCoalesceRunChangeDetection = r, o.lastRequestAnimationFrameId = -1, o.nativeRequestAnimationFrame = vl().nativeRequestAnimationFrame, Il(o) } static isInAngularZone() { return typeof Zone < "u" && Zone.current.get("isAngularZone") === !0 } static assertInAngularZone() { if (!e.isInAngularZone()) throw new y(909, !1) } static assertNotInAngularZone() { if (e.isInAngularZone()) throw new y(909, !1) } run(t, n, r) { return this._inner.run(t, n, r) } runTask(t, n, r, o) { let i = this._inner, s = i.scheduleEventTask("NgZoneEvent: " + o, t, El, xo, xo); try { return i.runTask(s, n, r) } finally { i.cancelTask(s) } } runGuarded(t, n, r) { return this._inner.runGuarded(t, n, r) } runOutsideAngular(t) { return this._outer.run(t) } }, El = {}; function gr(e) { if (e._nesting == 0 && !e.hasPendingMicrotasks && !e.isStable) try { e._nesting++, e.onMicrotaskEmpty.emit(null) } finally { if (e._nesting--, !e.hasPendingMicrotasks) try { e.runOutsideAngular(() => e.onStable.emit(null)) } finally { e.isStable = !0 } } } function wl(e) { e.isCheckStableRunning || e.lastRequestAnimationFrameId !== -1 || (e.lastRequestAnimationFrameId = e.nativeRequestAnimationFrame.call(Ve, () => { e.fakeTopEventTask || (e.fakeTopEventTask = Zone.root.scheduleEventTask("fakeTopEventTask", () => { e.lastRequestAnimationFrameId = -1, jn(e), e.isCheckStableRunning = !0, gr(e), e.isCheckStableRunning = !1 }, void 0, () => { }, () => { })), e.fakeTopEventTask.invoke() }), jn(e)) } function Il(e) { let t = () => { wl(e) }; e._inner = e._inner.fork({ name: "angular", properties: { isAngularZone: !0 }, onInvokeTask: (n, r, o, i, s, a) => { if (Cl(a)) return n.invokeTask(o, i, s, a); try { return No(e), n.invokeTask(o, i, s, a) } finally { (e.shouldCoalesceEventChangeDetection && i.type === "eventTask" || e.shouldCoalesceRunChangeDetection) && t(), Ao(e) } }, onInvoke: (n, r, o, i, s, a, u) => { try { return No(e), n.invoke(o, i, s, a, u) } finally { e.shouldCoalesceRunChangeDetection && t(), Ao(e) } }, onHasTask: (n, r, o, i) => { n.hasTask(o, i), r === o && (i.change == "microTask" ? (e._hasPendingMicrotasks = i.microTask, jn(e), gr(e)) : i.change == "macroTask" && (e.hasPendingMacrotasks = i.macroTask)) }, onHandleError: (n, r, o, i) => (n.handleError(o, i), e.runOutsideAngular(() => e.onError.emit(i)), !1) }) } function jn(e) { e._hasPendingMicrotasks || (e.shouldCoalesceEventChangeDetection || e.shouldCoalesceRunChangeDetection) && e.lastRequestAnimationFrameId !== -1 ? e.hasPendingMicrotasks = !0 : e.hasPendingMicrotasks = !1 } function No(e) { e._nesting++, e.isStable && (e.isStable = !1, e.onUnstable.emit(null)) } function Ao(e) { e._nesting--, gr(e) } function Cl(e) { return !Array.isArray(e) || e.length !== 1 ? !1 : e[0].data?.__ignore_ng_zone__ === !0 } var Es = (() => { let t = class t { constructor() { this.handler = null, this.internalCallbacks = [] } execute() { let r = [...this.internalCallbacks]; this.internalCallbacks.length = 0; for (let i of r) i(); return !!this.handler?.execute() || r.length > 0 } ngOnDestroy() { this.handler?.destroy(), this.handler = null, this.internalCallbacks.length = 0 } }; t.\u0275prov = I({ token: t, providedIn: "root", factory: () => new t }); let e = t; return e })(); function Ml(e, t) { let n = Xe(t, e), r = n[m]; bl(r, n); let o = n[K]; o !== null && n[yn] === null && (n[yn] = cr(o, n[Se])), ws(r, n, n[Y]) } function bl(e, t) { for (let n = t.length; n < e.blueprint.length; n++)t.push(e.blueprint[n]) } function ws(e, t, n) { Jn(t); try { let r = e.viewQuery; r !== null && Pn(1, r, n); let o = e.template; o !== null && is(e, t, o, 1, n), e.firstCreatePass && (e.firstCreatePass = !1), e.staticContentQueries && ds(e, t), e.staticViewQueries && Pn(2, e.viewQuery, n); let i = e.components; i !== null && Tl(t, i) } catch (r) { throw e.firstCreatePass && (e.incompleteFirstPass = !0, e.firstCreatePass = !1), r } finally { t[p] &= -5, Xn() } } function Tl(e, t) { for (let n = 0; n < t.length; n++)Ml(e, t[n]) } function Vn(e, t, n) { let r = n ? e.styles : null, o = n ? e.classes : null, i = 0; if (t !== null) for (let s = 0; s < t.length; s++) { let a = t[s]; if (typeof a == "number") i = a; else if (i == 1) o = no(o, a); else if (i == 2) { let u = a, c = t[++s]; r = no(r, u + ": " + c + ";") } } n ? e.styles = r : e.stylesWithoutHost = r, n ? e.classes = o : e.classesWithoutHost = o } var Bn = class extends lr { constructor(t) { super(), this.ngModule = t } resolveComponentFactory(t) { let n = St(t); return new $n(n, this.ngModule) } }; function Oo(e) { let t = []; for (let n in e) { if (!e.hasOwnProperty(n)) continue; let r = e[n]; r !== void 0 && t.push({ propName: Array.isArray(r) ? r[0] : r, templateName: n }) } return t } function _l(e) { let t = e.toLowerCase(); return t === "svg" ? Ja : t === "math" ? Xa : null } var Hn = class { constructor(t, n) { this.injector = t, this.parentInjector = n } get(t, n, r) { r = Tt(r); let o = this.injector.get(t, dn, r); return o !== dn || n === dn ? o : this.parentInjector.get(t, n, r) } }, $n = class extends It { get inputs() { let t = this.componentDef, n = t.inputTransforms, r = Oo(t.inputs); if (n !== null) for (let o of r) n.hasOwnProperty(o.propName) && (o.transform = n[o.propName]); return r } get outputs() { return Oo(this.componentDef.outputs) } constructor(t, n) { super(), this.componentDef = t, this.ngModule = n, this.componentType = t.type, this.selector = ja(t.selectors), this.ngContentSelectors = t.ngContentSelectors ? t.ngContentSelectors : [], this.isBoundToModule = !!n } create(t, n, r, o) { o = o || this.ngModule; let i = o instanceof ce ? o : o?.injector; i && this.componentDef.getStandaloneInjector !== null && (i = this.componentDef.getStandaloneInjector(i) || i); let s = i ? new Hn(t, i) : t, a = s.get(Ye, null); if (a === null) throw new y(407, !1); let u = s.get(Ac, null), c = s.get(Es, null), l = s.get(An, null), d = { rendererFactory: a, sanitizer: u, inlineEffectRunner: null, afterRenderEventManager: c, changeDetectionScheduler: l }, f = a.createRenderer(null, this.componentDef), h = this.componentDef.selectors[0][0] || "div", C = r ? zc(f, r, this.componentDef.encapsulation, s) : $i(f, h, _l(h)), B = 512; this.componentDef.signals ? B |= 4096 : this.componentDef.onPush || (B |= 16); let Ut = null; C !== null && (Ut = cr(C, s, !0)); let zt = us(0, null, null, 1, 0, null, null, null, null, null, null), ee = pr(null, zt, null, B, null, null, d, f, s, null, Ut); Jn(ee); let Rr, st; try { let G = this.componentDef, ge, Gt = null; G.findHostDirectiveDefs ? (ge = [], Gt = new Map, G.findHostDirectiveDefs(G, ge, Gt), ge.push(G)) : ge = [G]; let zs = Sl(ee, C), Gs = xl(zs, C, G, ge, ee, d, f); st = ru(zt, U), C && Ol(f, G, C, r), n !== void 0 && Rl(st, this.ngContentSelectors, n), Rr = Al(Gs, G, ge, Gt, ee, [Fl]), ws(zt, ee, null) } finally { Xn() } return new Un(this.componentType, Rr, Yi(st, ee), ee, st) } }, Un = class extends On { constructor(t, n, r, o, i) { super(), this.location = r, this._rootLView = o, this._tNode = i, this.previousInputValues = null, this.instance = n, this.hostView = this.changeDetectorRef = new Qe(o, void 0, !1), this.componentType = t } setInput(t, n) { let r = this._tNode.inputs, o; if (r !== null && (o = r[t])) { if (this.previousInputValues ??= new Map, this.previousInputValues.has(t) && Object.is(this.previousInputValues.get(t), n)) return; let i = this._rootLView; ps(i[m], i, o, t, n), this.previousInputValues.set(t, n); let s = Xe(this._tNode.index, i); Ds(s) } } get injector() { return new vt(this._tNode, this._rootLView) } destroy() { this.hostView.destroy() } onDestroy(t) { this.hostView.onDestroy(t) } }; function Sl(e, t) { let n = e[m], r = U; return e[r] = t, hr(n, r, 2, "#host", null) } function xl(e, t, n, r, o, i, s) { let a = o[m]; Nl(r, e, t, s); let u = null; t !== null && (u = cr(t, o[Se])); let c = i.rendererFactory.createRenderer(t, n), l = 16; n.signals ? l = 4096 : n.onPush && (l = 64); let d = pr(o, as(n), null, l, o[e.index], e, i, c, null, null, u); return a.firstCreatePass && Fn(a, e, r.length - 1), fs(o, d), o[e.index] = d } function Nl(e, t, n, r) { for (let o of e) t.mergedAttrs = Zn(t.mergedAttrs, o.hostAttrs); t.mergedAttrs !== null && (Vn(t, t.mergedAttrs, !0), n !== null && Zi(r, n, t)) } function Al(e, t, n, r, o, i) { let s = de(), a = o[m], u = le(s, o); cs(a, o, s, n, null, r); for (let l = 0; l < n.length; l++) { let d = s.directiveStart + l, f = qe(o, a, d, s); Ne(f, o) } ls(a, o, s), u && Ne(u, o); let c = qe(o, a, s.directiveStart + s.componentOffset, s); if (e[Y] = o[Y] = c, i !== null) for (let l of i) l(c, t); return ss(a, s, e), c } function Ol(e, t, n, r) { if (r) Dn(e, n, ["ng-version", "17.1.1"]); else { let { attrs: o, classes: i } = Va(t.selectors[0]); o && Dn(e, n, o), i && i.length > 0 && qi(e, n, i.join(" ")) } } function Rl(e, t, n) { let r = e.projection = []; for (let o = 0; o < t.length; o++) { let i = n[o]; r.push(i != null ? Array.from(i) : null) } } function Fl() { let e = de(); Ei(x()[m], e) } var gp = new RegExp(`^(\\d+)*(${Tc}|${bc})*(.*)`); function Pl(e, t, n) { return e[t] = n } function Is(e, t, n) { let r = e[t]; return Object.is(r, n) ? !1 : (e[t] = n, !0) } function kl(e, t, n, r) { return Is(e, Du(), n) ? t + ko(n) + r : tt } function Ro(e, t, n, r, o) { let i = t.inputs, s = o ? "class" : "style"; ps(e, n, i[s], s, r) } function Ll(e, t, n, r, o, i) { let s = t.consts, a = Do(s, o), u = hr(t, e, 2, r, a); return Yc(t, n, u, Do(s, i)), u.attrs !== null && Vn(u, u.attrs, !1), u.mergedAttrs !== null && Vn(u, u.mergedAttrs, !0), t.queries !== null && t.queries.elementStart(t, u), u } function pe(e, t, n, r) { let o = x(), i = et(), s = U + e, a = o[$], u = i.firstCreatePass ? Ll(s, i, o, t, n, r) : i.data[s], c = jl(i, o, u, a, t, e); o[s] = c; let l = qa(u); return Nt(u, !0), Zi(a, c, u), (u.flags & 32) !== 32 && yi() && Wi(i, o, c, u), au() === 0 && Ne(c, o), uu(), l && (Hc(i, o, u), ss(i, u, o)), r !== null && $c(o, u), pe } function he() { let e = de(); li() ? hu() : (e = e.parent, Nt(e, !1)); let t = e; du(t) && fu(), cu(); let n = et(); return n.firstCreatePass && (Ei(n, e), ei(e) && n.queries.elementEnd(e)), t.classesWithoutHost != null && Tu(t) && Ro(n, t, x(), t.classesWithoutHost, !0), t.stylesWithoutHost != null && _u(t) && Ro(n, t, x(), t.stylesWithoutHost, !1), he } var jl = (e, t, n, r, o, i) => (vi(!0), $i(r, o, Iu())); var Mt = "en-US"; var Vl = Mt; function Bl(e) { ha(e, "Expected localeId to be defined"), typeof e == "string" && (Vl = e.toLowerCase().replace(/_/g, "-")) } function Pt(e) { return !!e && typeof e.then == "function" } function mr(e) { return !!e && typeof e.subscribe == "function" } function Hl(e, t, n, r) { n >= e.data.length && (e.data[n] = null, e.blueprint[n] = null), t[n] = r } function Pe(e, t = "") { let n = x(), r = et(), o = e + U, i = r.firstCreatePass ? hr(r, o, 1, t, null) : r.data[o], s = $l(r, n, i, t, e); n[o] = s, yi() && Wi(r, n, s, i), Nt(i, !1) } var $l = (e, t, n, r, o) => (vi(!0), ic(t[$], r)); function nt(e, t, n) { let r = x(), o = kl(r, e, t, n); return o !== tt && cl(r, er(), o), nt } var Ae = class { }; var bt = class extends Ae { constructor(t) { super(), this.componentFactoryResolver = new Bn(this), this.instance = null; let n = new wt([...t.providers, { provide: Ae, useValue: this }, { provide: lr, useValue: this.componentFactoryResolver }], t.parent || rr(), t.debugName, new Set(["environment"])); this.injector = n, t.runEnvironmentInitializers && n.resolveInjectorInitializers() } destroy() { this.injector.destroy() } onDestroy(t) { this.injector.onDestroy(t) } }; function Ul(e, t, n = null) { return new bt({ providers: e, parent: t, debugName: n, runEnvironmentInitializers: !0 }).injector } var zl = (() => { let t = class t { constructor(r) { this._injector = r, this.cachedInjectors = new Map } getOrCreateStandaloneInjector(r) { if (!r.standalone) return null; if (!this.cachedInjectors.has(r)) { let o = ki(!1, r.type), i = o.length > 0 ? Ul([o], this._injector, `Standalone[${r.type.name}]`) : null; this.cachedInjectors.set(r, i) } return this.cachedInjectors.get(r) } ngOnDestroy() { try { for (let r of this.cachedInjectors.values()) r !== null && r.destroy() } finally { this.cachedInjectors.clear() } } }; t.\u0275prov = I({ token: t, providedIn: "environment", factory: () => new t(v(ce)) }); let e = t; return e })(); function kt(e) { vs("NgStandalone"), e.getStandaloneInjector = t => t.get(zl).getOrCreateStandaloneInjector(e) } function Gl(e, t) { let n = e[t]; return n === tt ? void 0 : n } function Wl(e, t, n, r, o, i) { let s = t + n; return Is(e, s, o) ? Pl(e, s + 1, i ? r.call(i, o) : r(o)) : Gl(e, s + 1) } function Cs(e, t) { let n = et(), r, o = e + U; n.firstCreatePass ? (r = ql(t, n.pipeRegistry), n.data[o] = r, r.onDestroy && (n.destroyHooks ??= []).push(o, r.onDestroy)) : r = n.data[o]; let i = r.factory || (r.factory = xe(r.type, !0)), s, a = N(Ft); try { let u = yt(!1), c = i(); return yt(u), Hl(n, x(), o, c), c } finally { N(a) } } function ql(e, t) { if (t) for (let n = t.length - 1; n >= 0; n--) { let r = t[n]; if (e === r.name) return r } } function Ms(e, t, n) { let r = e + U, o = x(), i = ou(o, r); return Zl(o, r) ? Wl(o, gu(), t, i.transform, n, i) : i.transform(n) } function Zl(e, t) { return e[m].data[t].pure } var bs = (() => { let t = class t { constructor() { this.taskId = 0, this.pendingTasks = new Set, this.hasPendingTasks = new re(!1) } get _hasPendingTasks() { return this.hasPendingTasks.value } add() { this._hasPendingTasks || this.hasPendingTasks.next(!0); let r = this.taskId++; return this.pendingTasks.add(r), r } remove(r) { this.pendingTasks.delete(r), this.pendingTasks.size === 0 && this._hasPendingTasks && this.hasPendingTasks.next(!1) } ngOnDestroy() { this.pendingTasks.clear(), this._hasPendingTasks && this.hasPendingTasks.next(!1) } }; t.\u0275fac = function (o) { return new (o || t) }, t.\u0275prov = I({ token: t, factory: t.\u0275fac, providedIn: "root" }); let e = t; return e })(); var Ts = new w(""); var Yl = new w("Application Initializer"), _s = (() => { let t = class t { constructor() { this.initialized = !1, this.done = !1, this.donePromise = new Promise((r, o) => { this.resolve = r, this.reject = o }), this.appInits = M(Yl, { optional: !0 }) ?? [] } runInitializers() { if (this.initialized) return; let r = []; for (let i of this.appInits) { let s = i(); if (Pt(s)) r.push(s); else if (mr(s)) { let a = new Promise((u, c) => { s.subscribe({ complete: u, error: c }) }); r.push(a) } } let o = () => { this.done = !0, this.resolve() }; Promise.all(r).then(() => { o() }).catch(i => { this.reject(i) }), r.length === 0 && o(), this.initialized = !0 } }; t.\u0275fac = function (o) { return new (o || t) }, t.\u0275prov = I({ token: t, factory: t.\u0275fac, providedIn: "root" }); let e = t; return e })(), Ql = new w("appBootstrapListener"); function Kl() { $r(() => { throw new y(600, !1) }) } function Jl(e) { return e.isBoundToModule } function Xl(e, t, n) { try { let r = n(); return Pt(r) ? r.catch(o => { throw t.runOutsideAngular(() => e.handleError(o)), o }) : r } catch (r) { throw t.runOutsideAngular(() => e.handleError(r)), r } } var Dr = (() => { let t = class t { constructor() { this._bootstrapListeners = [], this._runningTick = !1, this._destroyed = !1, this._destroyListeners = [], this._views = [], this.internalErrorHandler = M(es), this.afterRenderEffectManager = M(Es), this.componentTypes = [], this.components = [], this.isStable = M(bs).hasPendingTasks.pipe(on(r => !r)), this._injector = M(ce) } get destroyed() { return this._destroyed } get injector() { return this._injector } bootstrap(r, o) { let i = r instanceof It; if (!this._injector.get(_s).done) { let h = !i && $a(r), C = !1; throw new y(405, C) } let a; i ? a = r : a = this._injector.get(lr).resolveComponentFactory(r), this.componentTypes.push(a.componentType); let u = Jl(a) ? void 0 : this._injector.get(Ae), c = o || a.selector, l = a.create(Ot.NULL, [], c, u), d = l.location.nativeElement, f = l.injector.get(Ts, null); return f?.registerApplication(d), l.onDestroy(() => { this.detachView(l.hostView), hn(this.components, l), f?.unregisterApplication(d) }), this._loadComponent(l), l } tick() { if (this._runningTick) throw new y(101, !1); try { this._runningTick = !0; for (let r of this._views) r.detectChanges() } catch (r) { this.internalErrorHandler(r) } finally { try { let r = this.afterRenderEffectManager.execute() } catch (r) { this.internalErrorHandler(r) } this._runningTick = !1 } } attachView(r) { let o = r; this._views.push(o), o.attachToAppRef(this) } detachView(r) { let o = r; hn(this._views, o), o.detachFromAppRef() } _loadComponent(r) { this.attachView(r.hostView), this.tick(), this.components.push(r); let o = this._injector.get(Ql, []);[...this._bootstrapListeners, ...o].forEach(i => i(r)) } ngOnDestroy() { if (!this._destroyed) try { this._destroyListeners.forEach(r => r()), this._views.slice().forEach(r => r.destroy()) } finally { this._destroyed = !0, this._views = [], this._bootstrapListeners = [], this._destroyListeners = [] } } onDestroy(r) { return this._destroyListeners.push(r), () => hn(this._destroyListeners, r) } destroy() { if (this._destroyed) throw new y(406, !1); let r = this._injector; r.destroy && !r.destroyed && r.destroy() } get viewCount() { return this._views.length } warnIfDestroyed() { } }; t.\u0275fac = function (o) { return new (o || t) }, t.\u0275prov = I({ token: t, factory: t.\u0275fac, providedIn: "root" }); let e = t; return e })(); function hn(e, t) { let n = e.indexOf(t); n > -1 && e.splice(n, 1) } var ed = (() => { let t = class t { constructor() { this.zone = M(T), this.applicationRef = M(Dr) } initialize() { this._onMicrotaskEmptySubscription || (this._onMicrotaskEmptySubscription = this.zone.onMicrotaskEmpty.subscribe({ next: () => { this.zone.run(() => { this.applicationRef.tick() }) } })) } ngOnDestroy() { this._onMicrotaskEmptySubscription?.unsubscribe() } }; t.\u0275fac = function (o) { return new (o || t) }, t.\u0275prov = I({ token: t, factory: t.\u0275fac, providedIn: "root" }); let e = t; return e })(); function td(e) { return [{ provide: T, useFactory: e }, { provide: Ze, multi: !0, useFactory: () => { let t = M(ed, { optional: !0 }); return () => t.initialize() } }, { provide: Ze, multi: !0, useFactory: () => { let t = M(id); return () => { t.initialize() } } }, { provide: es, useFactory: nd }] } function nd() { let e = M(T), t = M(z); return n => e.runOutsideAngular(() => t.handleError(n)) } function rd(e) { let t = td(() => new T(od(e))); return Pi([[], t]) } function od(e) { return { enableLongStackTrace: !1, shouldCoalesceEventChangeDetection: e?.eventCoalescing ?? !1, shouldCoalesceRunChangeDetection: e?.runCoalescing ?? !1 } } var id = (() => { let t = class t { constructor() { this.subscription = new b, this.initialized = !1, this.zone = M(T), this.pendingTasks = M(bs) } initialize() { if (this.initialized) return; this.initialized = !0; let r = null; !this.zone.isStable && !this.zone.hasPendingMacrotasks && !this.zone.hasPendingMicrotasks && (r = this.pendingTasks.add()), this.zone.runOutsideAngular(() => { this.subscription.add(this.zone.onStable.subscribe(() => { T.assertNotInAngularZone(), queueMicrotask(() => { r !== null && !this.zone.hasPendingMacrotasks && !this.zone.hasPendingMicrotasks && (this.pendingTasks.remove(r), r = null) }) })) }), this.subscription.add(this.zone.onUnstable.subscribe(() => { T.assertInAngularZone(), r ??= this.pendingTasks.add() })) } ngOnDestroy() { this.subscription.unsubscribe() } }; t.\u0275fac = function (o) { return new (o || t) }, t.\u0275prov = I({ token: t, factory: t.\u0275fac, providedIn: "root" }); let e = t; return e })(); function sd() { return typeof $localize < "u" && $localize.locale || Mt } var yr = new w("LocaleId", { providedIn: "root", factory: () => M(yr, g.Optional | g.SkipSelf) || sd() }); var Ss = new w("PlatformDestroyListeners"); var gt = null; function ad(e = [], t) { return Ot.create({ name: t, providers: [{ provide: At, useValue: "platform" }, { provide: Ss, useValue: new Set([() => gt = null]) }, ...e] }) } function ud(e = []) { if (gt) return gt; let t = ad(e); return gt = t, Kl(), cd(t), t } function cd(e) { e.get(ir, null)?.forEach(n => n()) } function xs(e) { try { let { rootComponent: t, appProviders: n, platformProviders: r } = e, o = ud(r), i = [rd(), ...n || []], a = new bt({ providers: i, parent: o, debugName: "", runEnvironmentInitializers: !1 }).injector, u = a.get(T); return u.run(() => { a.resolveInjectorInitializers(); let c = a.get(z, null), l; u.runOutsideAngular(() => { l = u.onError.subscribe({ next: h => { c.handleError(h) } }) }); let d = () => a.destroy(), f = o.get(Ss); return f.add(d), a.onDestroy(() => { l.unsubscribe(), f.delete(d) }), Xl(c, u, () => { let h = a.get(_s); return h.runInitializers(), h.donePromise.then(() => { let C = a.get(yr, Mt); Bl(C || Mt); let B = a.get(Dr); return t !== void 0 && B.bootstrap(t), B }) }) }) } catch (t) { return Promise.reject(t) } } var vr = null; function Ir() { return vr } function Ns(e) { vr || (vr = e) } var jt = class { }, X = new w("DocumentToken"); function As(e, t) { t = encodeURIComponent(t); for (let n of e.split(";")) { let r = n.indexOf("="), [o, i] = r == -1 ? [n, ""] : [n.slice(0, r), n.slice(r + 1)]; if (o.trim() === t) return decodeURIComponent(i) } return null } function pd(e, t) { return new y(2100, !1) } var Er = class { createSubscription(t, n) { return fr(() => t.subscribe({ next: n, error: r => { throw r } })) } dispose(t) { fr(() => t.unsubscribe()) } }, wr = class { createSubscription(t, n) { return t.then(n, r => { throw r }) } dispose(t) { } }, hd = new wr, gd = new Er, Os = (() => { let t = class t { constructor(r) { this._latestValue = null, this._subscription = null, this._obj = null, this._strategy = null, this._ref = r } ngOnDestroy() { this._subscription && this._dispose(), this._ref = null } transform(r) { return this._obj ? r !== this._obj ? (this._dispose(), this.transform(r)) : this._latestValue : (r && this._subscribe(r), this._latestValue) } _subscribe(r) { this._obj = r, this._strategy = this._selectStrategy(r), this._subscription = this._strategy.createSubscription(r, o => this._updateLatestValue(r, o)) } _selectStrategy(r) { if (Pt(r)) return hd; if (mr(r)) return gd; throw pd(t, r) } _dispose() { this._strategy.dispose(this._subscription), this._latestValue = null, this._subscription = null, this._obj = null } _updateLatestValue(r, o) { r === this._obj && (this._latestValue = o, this._ref.markForCheck()) } }; t.\u0275fac = function (o) { return new (o || t)(Ft(ys, 16)) }, t.\u0275pipe = Go({ name: "async", type: t, pure: !1, standalone: !0 }); let e = t; return e })(); var Cr = (() => { let t = class t { }; t.\u0275fac = function (o) { return new (o || t) }, t.\u0275mod = Yn({ type: t }), t.\u0275inj = Wn({}); let e = t; return e })(), Rs = "browser", md = "server"; function Mr(e) { return e === md } var Vt = class { }; var _r = class extends jt { constructor() { super(...arguments), this.supportsDOMEvents = !0 } }, Sr = class e extends _r { static makeCurrent() { Ns(new e) } onAndCancel(t, n, r) { return t.addEventListener(n, r), () => { t.removeEventListener(n, r) } } dispatchEvent(t, n) { t.dispatchEvent(n) } remove(t) { t.parentNode && t.parentNode.removeChild(t) } createElement(t, n) { return n = n || this.getDefaultDocument(), n.createElement(t) } createHtmlDocument() { return document.implementation.createHTMLDocument("fakeTitle") } getDefaultDocument() { return document } isElementNode(t) { return t.nodeType === Node.ELEMENT_NODE } isShadowRoot(t) { return t instanceof DocumentFragment } getGlobalEventTarget(t, n) { return n === "window" ? window : n === "document" ? t : n === "body" ? t.body : null } getBaseHref(t) { let n = vd(); return n == null ? null : Ed(n) } resetBaseElement() { rt = null } getUserAgent() { return window.navigator.userAgent } getCookie(t) { return As(document.cookie, t) } }, rt = null; function vd() { return rt = rt || document.querySelector("base"), rt ? rt.getAttribute("href") : null } function Ed(e) { return new URL(e, document.baseURI).pathname } var wd = (() => { let t = class t { build() { return new XMLHttpRequest } }; t.\u0275fac = function (o) { return new (o || t) }, t.\u0275prov = I({ token: t, factory: t.\u0275fac }); let e = t; return e })(), xr = new w("EventManagerPlugins"), Ls = (() => { let t = class t { constructor(r, o) { this._zone = o, this._eventNameToPlugin = new Map, r.forEach(i => { i.manager = this }), this._plugins = r.slice().reverse() } addEventListener(r, o, i) { return this._findPluginFor(o).addEventListener(r, o, i) } getZone() { return this._zone } _findPluginFor(r) { let o = this._eventNameToPlugin.get(r); if (o) return o; if (o = this._plugins.find(s => s.supports(r)), !o) throw new y(5101, !1); return this._eventNameToPlugin.set(r, o), o } }; t.\u0275fac = function (o) { return new (o || t)(v(xr), v(T)) }, t.\u0275prov = I({ token: t, factory: t.\u0275fac }); let e = t; return e })(), Bt = class { constructor(t) { this._doc = t } }, br = "ng-app-id", js = (() => { let t = class t { constructor(r, o, i, s = {}) { this.doc = r, this.appId = o, this.nonce = i, this.platformId = s, this.styleRef = new Map, this.hostNodes = new Set, this.styleNodesInDOM = this.collectServerRenderedStyles(), this.platformIsServer = Mr(s), this.resetHostNodes() } addStyles(r) { for (let o of r) this.changeUsageCount(o, 1) === 1 && this.onStyleAdded(o) } removeStyles(r) { for (let o of r) this.changeUsageCount(o, -1) <= 0 && this.onStyleRemoved(o) } ngOnDestroy() { let r = this.styleNodesInDOM; r && (r.forEach(o => o.remove()), r.clear()); for (let o of this.getAllStyles()) this.onStyleRemoved(o); this.resetHostNodes() } addHost(r) { this.hostNodes.add(r); for (let o of this.getAllStyles()) this.addStyleToHost(r, o) } removeHost(r) { this.hostNodes.delete(r) } getAllStyles() { return this.styleRef.keys() } onStyleAdded(r) { for (let o of this.hostNodes) this.addStyleToHost(o, r) } onStyleRemoved(r) { let o = this.styleRef; o.get(r)?.elements?.forEach(i => i.remove()), o.delete(r) } collectServerRenderedStyles() { let r = this.doc.head?.querySelectorAll(`style[${br}="${this.appId}"]`); if (r?.length) { let o = new Map; return r.forEach(i => { i.textContent != null && o.set(i.textContent, i) }), o } return null } changeUsageCount(r, o) { let i = this.styleRef; if (i.has(r)) { let s = i.get(r); return s.usage += o, s.usage } return i.set(r, { usage: o, elements: [] }), o } getStyleElement(r, o) { let i = this.styleNodesInDOM, s = i?.get(o); if (s?.parentNode === r) return i.delete(o), s.removeAttribute(br), s; { let a = this.doc.createElement("style"); return this.nonce && a.setAttribute("nonce", this.nonce), a.textContent = o, this.platformIsServer && a.setAttribute(br, this.appId), r.appendChild(a), a } } addStyleToHost(r, o) { let i = this.getStyleElement(r, o), s = this.styleRef, a = s.get(o)?.elements; a ? a.push(i) : s.set(o, { elements: [i], usage: 1 }) } resetHostNodes() { let r = this.hostNodes; r.clear(), r.add(this.doc.head) } }; t.\u0275fac = function (o) { return new (o || t)(v(X), v(or), v(sr, 8), v(Fe)) }, t.\u0275prov = I({ token: t, factory: t.\u0275fac }); let e = t; return e })(), Tr = { svg: "http://www.w3.org/2000/svg", xhtml: "http://www.w3.org/1999/xhtml", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/", math: "http://www.w3.org/1998/MathML/" }, Ar = /%COMP%/g, Vs = "%COMP%", Id = `_nghost-${Vs}`, Cd = `_ngcontent-${Vs}`, Md = !0, bd = new w("RemoveStylesOnCompDestroy", { providedIn: "root", factory: () => Md }); function Td(e) { return Cd.replace(Ar, e) } function _d(e) { return Id.replace(Ar, e) } function Bs(e, t) { return t.map(n => n.replace(Ar, e)) } var Fs = (() => { let t = class t { constructor(r, o, i, s, a, u, c, l = null) { this.eventManager = r, this.sharedStylesHost = o, this.appId = i, this.removeStylesOnCompDestroy = s, this.doc = a, this.platformId = u, this.ngZone = c, this.nonce = l, this.rendererByCompId = new Map, this.platformIsServer = Mr(u), this.defaultRenderer = new ot(r, a, c, this.platformIsServer) } createRenderer(r, o) { if (!r || !o) return this.defaultRenderer; this.platformIsServer && o.encapsulation === j.ShadowDom && (o = te(W({}, o), { encapsulation: j.Emulated })); let i = this.getOrCreateRenderer(r, o); return i instanceof Ht ? i.applyToHost(r) : i instanceof it && i.applyStyles(), i } getOrCreateRenderer(r, o) { let i = this.rendererByCompId, s = i.get(o.id); if (!s) { let a = this.doc, u = this.ngZone, c = this.eventManager, l = this.sharedStylesHost, d = this.removeStylesOnCompDestroy, f = this.platformIsServer; switch (o.encapsulation) { case j.Emulated: s = new Ht(c, l, o, this.appId, d, a, u, f); break; case j.ShadowDom: return new Nr(c, l, r, o, a, u, this.nonce, f); default: s = new it(c, l, o, d, a, u, f); break }i.set(o.id, s) } return s } ngOnDestroy() { this.rendererByCompId.clear() } }; t.\u0275fac = function (o) { return new (o || t)(v(Ls), v(js), v(or), v(bd), v(X), v(Fe), v(T), v(sr)) }, t.\u0275prov = I({ token: t, factory: t.\u0275fac }); let e = t; return e })(), ot = class { constructor(t, n, r, o) { this.eventManager = t, this.doc = n, this.ngZone = r, this.platformIsServer = o, this.data = Object.create(null), this.throwOnSyntheticProps = !0, this.destroyNode = null } destroy() { } createElement(t, n) { return n ? this.doc.createElementNS(Tr[n] || n, t) : this.doc.createElement(t) } createComment(t) { return this.doc.createComment(t) } createText(t) { return this.doc.createTextNode(t) } appendChild(t, n) { (Ps(t) ? t.content : t).appendChild(n) } insertBefore(t, n, r) { t && (Ps(t) ? t.content : t).insertBefore(n, r) } removeChild(t, n) { t && t.removeChild(n) } selectRootElement(t, n) { let r = typeof t == "string" ? this.doc.querySelector(t) : t; if (!r) throw new y(-5104, !1); return n || (r.textContent = ""), r } parentNode(t) { return t.parentNode } nextSibling(t) { return t.nextSibling } setAttribute(t, n, r, o) { if (o) { n = o + ":" + n; let i = Tr[o]; i ? t.setAttributeNS(i, n, r) : t.setAttribute(n, r) } else t.setAttribute(n, r) } removeAttribute(t, n, r) { if (r) { let o = Tr[r]; o ? t.removeAttributeNS(o, n) : t.removeAttribute(`${r}:${n}`) } else t.removeAttribute(n) } addClass(t, n) { t.classList.add(n) } removeClass(t, n) { t.classList.remove(n) } setStyle(t, n, r, o) { o & (fe.DashCase | fe.Important) ? t.style.setProperty(n, r, o & fe.Important ? "important" : "") : t.style[n] = r } removeStyle(t, n, r) { r & fe.DashCase ? t.style.removeProperty(n) : t.style[n] = "" } setProperty(t, n, r) { t != null && (t[n] = r) } setValue(t, n) { t.nodeValue = n } listen(t, n, r) { if (typeof t == "string" && (t = Ir().getGlobalEventTarget(this.doc, t), !t)) throw new Error(`Unsupported event target ${t} for event ${n}`); return this.eventManager.addEventListener(t, n, this.decoratePreventDefault(r)) } decoratePreventDefault(t) { return n => { if (n === "__ngUnwrap__") return t; (this.platformIsServer ? this.ngZone.runGuarded(() => t(n)) : t(n)) === !1 && n.preventDefault() } } }; function Ps(e) { return e.tagName === "TEMPLATE" && e.content !== void 0 } var Nr = class extends ot { constructor(t, n, r, o, i, s, a, u) { super(t, i, s, u), this.sharedStylesHost = n, this.hostEl = r, this.shadowRoot = r.attachShadow({ mode: "open" }), this.sharedStylesHost.addHost(this.shadowRoot); let c = Bs(o.id, o.styles); for (let l of c) { let d = document.createElement("style"); a && d.setAttribute("nonce", a), d.textContent = l, this.shadowRoot.appendChild(d) } } nodeOrShadowRoot(t) { return t === this.hostEl ? this.shadowRoot : t } appendChild(t, n) { return super.appendChild(this.nodeOrShadowRoot(t), n) } insertBefore(t, n, r) { return super.insertBefore(this.nodeOrShadowRoot(t), n, r) } removeChild(t, n) { return super.removeChild(this.nodeOrShadowRoot(t), n) } parentNode(t) { return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t))) } destroy() { this.sharedStylesHost.removeHost(this.shadowRoot) } }, it = class extends ot { constructor(t, n, r, o, i, s, a, u) { super(t, i, s, a), this.sharedStylesHost = n, this.removeStylesOnCompDestroy = o, this.styles = u ? Bs(u, r.styles) : r.styles } applyStyles() { this.sharedStylesHost.addStyles(this.styles) } destroy() { this.removeStylesOnCompDestroy && this.sharedStylesHost.removeStyles(this.styles) } }, Ht = class extends it { constructor(t, n, r, o, i, s, a, u) { let c = o + "-" + r.id; super(t, n, r, i, s, a, u, c), this.contentAttr = Td(c), this.hostAttr = _d(c) } applyToHost(t) { this.applyStyles(), this.setAttribute(t, this.hostAttr, "") } createElement(t, n) { let r = super.createElement(t, n); return super.setAttribute(r, this.contentAttr, ""), r } }, Sd = (() => { let t = class t extends Bt { constructor(r) { super(r) } supports(r) { return !0 } addEventListener(r, o, i) { return r.addEventListener(o, i, !1), () => this.removeEventListener(r, o, i) } removeEventListener(r, o, i) { return r.removeEventListener(o, i) } }; t.\u0275fac = function (o) { return new (o || t)(v(X)) }, t.\u0275prov = I({ token: t, factory: t.\u0275fac }); let e = t; return e })(), ks = ["alt", "control", "meta", "shift"], xd = { "\b": "Backspace", "	": "Tab", "\x7F": "Delete", "\x1B": "Escape", Del: "Delete", Esc: "Escape", Left: "ArrowLeft", Right: "ArrowRight", Up: "ArrowUp", Down: "ArrowDown", Menu: "ContextMenu", Scroll: "ScrollLock", Win: "OS" }, Nd = { alt: e => e.altKey, control: e => e.ctrlKey, meta: e => e.metaKey, shift: e => e.shiftKey }, Ad = (() => { let t = class t extends Bt { constructor(r) { super(r) } supports(r) { return t.parseEventName(r) != null } addEventListener(r, o, i) { let s = t.parseEventName(o), a = t.eventCallback(s.fullKey, i, this.manager.getZone()); return this.manager.getZone().runOutsideAngular(() => Ir().onAndCancel(r, s.domEventName, a)) } static parseEventName(r) { let o = r.toLowerCase().split("."), i = o.shift(); if (o.length === 0 || !(i === "keydown" || i === "keyup")) return null; let s = t._normalizeKey(o.pop()), a = "", u = o.indexOf("code"); if (u > -1 && (o.splice(u, 1), a = "code."), ks.forEach(l => { let d = o.indexOf(l); d > -1 && (o.splice(d, 1), a += l + ".") }), a += s, o.length != 0 || s.length === 0) return null; let c = {}; return c.domEventName = i, c.fullKey = a, c } static matchEventFullKeyCode(r, o) { let i = xd[r.key] || r.key, s = ""; return o.indexOf("code.") > -1 && (i = r.code, s = "code."), i == null || !i ? !1 : (i = i.toLowerCase(), i === " " ? i = "space" : i === "." && (i = "dot"), ks.forEach(a => { if (a !== i) { let u = Nd[a]; u(r) && (s += a + ".") } }), s += i, s === o) } static eventCallback(r, o, i) { return s => { t.matchEventFullKeyCode(s, r) && i.runGuarded(() => o(s)) } } static _normalizeKey(r) { return r === "esc" ? "escape" : r } }; t.\u0275fac = function (o) { return new (o || t)(v(X)) }, t.\u0275prov = I({ token: t, factory: t.\u0275fac }); let e = t; return e })(); function Hs(e, t) { return xs(W({ rootComponent: e }, Od(t))) } function Od(e) { return { appProviders: [...Ld, ...e?.providers ?? []], platformProviders: kd } } function Rd() { Sr.makeCurrent() } function Fd() { return new z } function Pd() { return Vi(document), document } var kd = [{ provide: Fe, useValue: Rs }, { provide: ir, useValue: Rd, multi: !0 }, { provide: X, useFactory: Pd, deps: [] }]; var Ld = [{ provide: At, useValue: "root" }, { provide: z, useFactory: Fd, deps: [] }, { provide: xr, useClass: Sd, multi: !0, deps: [X, T, Fe] }, { provide: xr, useClass: Ad, multi: !0, deps: [X] }, Fs, js, Ls, { provide: Ye, useExisting: Fs }, { provide: Vt, useClass: wd, deps: [] }, []]; var jd = { url: "", deserializer: e => JSON.parse(e.data), serializer: e => JSON.stringify(e) }, Vd = "WebSocketSubject.error must be called with an object with an error code, and an optional reason: { code: number, reason: string }", $t = class e extends Ee { constructor(t, n) { if (super(), this._socket = null, t instanceof ve) this.destination = n, this.source = t; else { let r = this._config = Object.assign({}, jd); if (this._output = new O, typeof t == "string") r.url = t; else for (let o in t) t.hasOwnProperty(o) && (r[o] = t[o]); if (!r.WebSocketCtor && WebSocket) r.WebSocketCtor = WebSocket; else if (!r.WebSocketCtor) throw new Error("no WebSocket constructor can be found"); this.destination = new we } } lift(t) { let n = new e(this._config, this.destination); return n.operator = t, n.source = this, n } _resetState() { this._socket = null, this.source || (this.destination = new we), this._output = new O } multiplex(t, n, r) { let o = this; return new ve(i => { try { o.next(t()) } catch (a) { i.error(a) } let s = o.subscribe({ next: a => { try { r(a) && i.next(a) } catch (u) { i.error(u) } }, error: a => i.error(a), complete: () => i.complete() }); return () => { try { o.next(n()) } catch (a) { i.error(a) } s.unsubscribe() } }) } _connectSocket() { let { WebSocketCtor: t, protocol: n, url: r, binaryType: o } = this._config, i = this._output, s = null; try { s = n ? new t(r, n) : new t(r), this._socket = s, o && (this._socket.binaryType = o) } catch (u) { i.error(u); return } let a = new b(() => { this._socket = null, s && s.readyState === 1 && s.close() }); s.onopen = u => { let { _socket: c } = this; if (!c) { s.close(), this._resetState(); return } let { openObserver: l } = this._config; l && l.next(u); let d = this.destination; this.destination = H.create(f => { if (s.readyState === 1) try { let { serializer: h } = this._config; s.send(h(f)) } catch (h) { this.destination.error(h) } }, f => { let { closingObserver: h } = this._config; h && h.next(void 0), f && f.code ? s.close(f.code, f.reason) : i.error(new TypeError(Vd)), this._resetState() }, () => { let { closingObserver: f } = this._config; f && f.next(void 0), s.close(), this._resetState() }), d && d instanceof we && a.add(d.subscribe(this.destination)) }, s.onerror = u => { this._resetState(), i.error(u) }, s.onclose = u => { s === this._socket && this._resetState(); let { closeObserver: c } = this._config; c && c.next(u), u.wasClean ? i.complete() : i.error(u) }, s.onmessage = u => { try { let { deserializer: c } = this._config; i.next(c(u)) } catch (c) { i.error(c) } } } _subscribe(t) { let { source: n } = this; return n ? n.subscribe(t) : (this._socket || this._connectSocket(), this._output.subscribe(t), t.add(() => { let { _socket: r } = this; this._output.observers.length === 0 && (r && (r.readyState === 1 || r.readyState === 0) && r.close(), this._resetState()) }), t) } unsubscribe() { let { _socket: t } = this; t && (t.readyState === 1 || t.readyState === 0) && t.close(), this._resetState(), super.unsubscribe() } }; function Or(e) { return new $t(e) } var $s = (() => { let t = class t { constructor() { this.millis$ = new re(678) } onMsg(r) { console.log("message received: " + r.millis), this.millis$.next(r.millis) } ngOnInit() { Or("ws://artnet.local:80/ws").subscribe({ next: o => this.onMsg(o), error: o => console.log(o), complete: () => console.log("complete") }) } }; t.\u0275fac = function (o) { return new (o || t) }, t.\u0275cmp = _t({ type: t, selectors: [["app-millis"]], standalone: !0, features: [kt], decls: 3, vars: 3, template: function (o, i) { o & 1 && (pe(0, "p"), Pe(1), Cs(2, "async"), he()), o & 2 && (Rt(), nt("millis is ", Ms(2, 1, i.millis$), "")) }, dependencies: [Cr, Os], encapsulation: 2 }); let e = t; return e })(); var Us = (() => { let t = class t { constructor() { this.title = "dmx-web-app" } }; t.\u0275fac = function (o) { return new (o || t) }, t.\u0275cmp = _t({ type: t, selectors: [["app-root"]], standalone: !0, features: [kt], decls: 6, vars: 1, template: function (o, i) { o & 1 && (pe(0, "h1"), Pe(1), he(), pe(2, "p"), Pe(3, "Congratulations! Your app is running. \u{1F389}"), he(), pe(4, "app-millis"), Pe(5, "System uptime unavailable"), he()), o & 2 && (Rt(), nt("Hello, ", i.title, "")) }, dependencies: [$s], encapsulation: 2 }); let e = t; return e })(); Hs(Us).catch(e => console.error(e));
